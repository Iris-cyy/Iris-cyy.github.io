<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>花落知多少</title>
  
  <subtitle>Nice to meet you :)</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://iris-cyy.github.io/"/>
  <updated>2020-06-15T09:59:45.546Z</updated>
  <id>https://iris-cyy.github.io/</id>
  
  <author>
    <name>Irisssy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Compilation Principle】Semantic Analysis</title>
    <link href="https://iris-cyy.github.io//Notes/Compilation-Principle/2020-06-15/cp_semantic/"/>
    <id>https://iris-cyy.github.io//Notes/Compilation-Principle/2020-06-15/cp_semantic/</id>
    <published>2020-06-15T01:56:51.000Z</published>
    <updated>2020-06-15T09:59:45.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="属性文法"><a href="#属性文法" class="headerlink" title="属性文法"></a>属性文法</h2><p>如果X是一个文法符号，a是X的一个属性，那么我们把与X关联的a的值记作X.a</p><p>在语法制导语义(syntax-directed semantics)中，属性直接与语言的文法符号相联系(终结符号或非终结符号)，若有一个属性的集合$a_1 , . . . , a_k$ ，语法制导语义的原理应用于每个文法规则$X_0→X_1 X_2 . . . X_n$（这里$X_0$ 是一个非终结符号，其他的$X_i$都是任意符号），每个文法符号$X_i$ 的属性$X_i .a_j$ 的值与规则中其他符号的属性值有关。每个关系用属性等式(attribute equation)或语义规则(semantics rule) 表示，形式如下：<br>$$<br>X_i .a_j = f_{ij} (X_0.a_1 , . . . , X_0.a_k ，X_1.a_1 , . . . , X_1.a_k , . . . , X_n .a_1 , . . . , X_n .a_k )<br>$$<br><img src="/images/comp/com-prin6.assets/image-20200615113519905.png" alt="image-20200615113519905"></p><blockquote><p>eg.</p><p>number → number digit | digit<br>digit → 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</p><p>属性文法：</p><p><img src="/images/comp/com-prin6.assets/image-20200615113808216.png" alt="image-20200615113808216"></p><p>语法树：</p><p><img src="/images/comp/com-prin6.assets/image-20200615113824187.png" alt="image-20200615113824187" style="zoom: 67%;" /></p></blockquote><h3 id="相关图（associated-dependency-graph）"><a href="#相关图（associated-dependency-graph）" class="headerlink" title="相关图（associated dependency graph）"></a>相关图（associated dependency graph）</h3><p>表示属性计算时值的传递关系（有向无环图DAG），计算顺序遵循拓扑排序</p><p><img src="/images/comp/com-prin6.assets/image-20200615142459552.png" alt="image-20200615142459552" style="zoom:67%;" /></p><h3 id="合成和继承属性"><a href="#合成和继承属性" class="headerlink" title="合成和继承属性"></a>合成和继承属性</h3><ul><li><p><strong>综合属性</strong>(synthesized)：在语法树中所有的相关都从子节点指向父节点。</p><p>等价地，给定一个文法规则$A →X_1 X_2 . . . X_n $，左边仅有一个a 的相关属性等式有以下形式$A.a = f (X_1.a_1，. . . ，X_1 .a_k，. . . ，X_n .a_1，. . . ，X_n .a_k )$。</p><p>一个属性文法中所有的属性都是合成的，就称作<strong>S-属性文法</strong>(S-attributed grammar)。</p><p>S属性文法的属性计算可以通过对语法树自底向上的后续遍历来进行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">procedurepostEval(T:treenode);</span><br><span class="line">begin</span><br><span class="line">foreachchildCofTdo</span><br><span class="line">postEval(C);</span><br><span class="line">computeallsynthesizedattributesofT;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p><strong>继承属性</strong>(inherited)：一个属性如果不是合成的，则称作继承属性</p><ul><li>inheritance from parent to siblings</li><li>inheritance from sibling to sibling</li></ul><p><img src="/images/comp/com-prin6.assets/image-20200615145554033.png" alt="image-20200615145554033" style="zoom:67%;" /></p><p>使用前序遍历或者前序中序遍历相结合的方式来进行属性计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">procedurepreEval(T:treenode);</span><br><span class="line">begin</span><br><span class="line">foreachchildCofTdo</span><br><span class="line">computeallinheritedattributesofC;</span><br><span class="line">preEval(C);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure></li></ul><h3 id="语法分析时的属性计算"><a href="#语法分析时的属性计算" class="headerlink" title="语法分析时的属性计算"></a>语法分析时的属性计算</h3><p><strong>L-属性文法</strong>（L-attributed）：如果对每个继承属性$a_j$和每个文法规则$X_0 →X_1 X_2 . . . X_n$，$a_j$ 的相关等式都有以下形式$X_i .a_j = f_{i j} (X_0 .a_1 , . . . , X_0 .a_k ，X_1 .a_1 , . . . , X_1 .a_k ，. . . ，X_{i -1} .a_1 , . . . , X{i -1} .a_k )$，也就是说，在$X_i$ 处$a_j$ 的值只依赖于在文法规则中Xi 左边出现的符号$X_0 , . . . , X_{i -1}$ 的属性。</p><p><strong>S-属性文法是L-属性文法的特例</strong></p><p>L-属性文法的继承属性不依赖于综合属性</p><ul><li><p>LR分析中综合属性的计算：LR分析程序中通常由一个值栈存储综合属性（如果对每个文法符号有不止一个属性，可能是联合或结构）。值栈将和分析栈并行操作，根据属性等式每次在分析栈出现移进或规约来计算新值。</p><p><img src="/images/comp/com-prin6.assets/image-20200615154418372.png" alt="image-20200615154418372"></p><p><img src="/images/comp/com-prin6.assets/image-20200615154428144.png" alt="image-20200615154428144"></p></li><li><p>在LR分析中继承前面计算的综合属性：因为LR分析使用从左向右的赋值策略，因为这些值已经被压进了值栈，所以与规则右边非终止符相关的动作可以把符号的综合属性使用到规则的左边。为了简要说明这一点，可考虑产生式选择$A→B C$，假设$C$有一个继承属性$I $和以某种方式依赖于$B：C.i = f (B.s) $的综合属性$s$。通过在$B$ 和$C$ 之间引入一个$\epsilon$-产生式安排值栈栈顶的存储，在识别C 之前的$C.i$ 值可以存进一个变量中</p><p><img src="/images/comp/com-prin6.assets/image-20200615155447855.png" alt="image-20200615155447855"></p></li></ul><p>通常在计算属性时，利用参数和返回的函数值与属性值进行通信，而不是把它们作为字段存储在语法树的记录结构中。</p><p><strong>给定一个属性文法，通过适当地修改文法，而无须改变文法的语言，所有的继承属性可以改变成合成属性。</strong></p><blockquote><p>eg.</p><p>decl → type var-list<br>type → int | float<br>var- list → id , var- list | id</p><p>其中dtype属性是继承属性，重写如下：</p><p>decl → var-list id<br>var- list → var- list id, | type<br>type → int | float</p><p><img src="/images/comp/com-prin6.assets/image-20200615163842027.png" alt="image-20200615163842027"></p><p>dtype属性的依赖图：</p><p><img src="/images/comp/com-prin6.assets/image-20200615163923025.png" alt="image-20200615163923025" style="zoom: 67%;" /></p><p>在图中父节点或兄弟节点值的两个id.dtype值的依赖用虚线画出。而这些依赖的出现违反了在这个属性文法中没有继承属性的要求，事实上这些依赖总是留在语法树中(即是非递归的)，并且可能由相应的父节点的操作实现。因此，这些操作不看成是继承的。</p></blockquote><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul><li><p>线性表</p><p>insert: O(1), lookup: O(n), delete: O(n)</p><p>效率不高，可以应用在不追求效率的编译器上</p></li><li><p>搜索树（二叉树、AVL树、B树…）</p><p>delete非常麻烦</p><p>少见</p></li><li><p>哈希表</p><p>insert, lookup, delete都在O(1)时间</p><p>稳定性好，效率高，首选</p></li></ul><p>哈希表中每一项可以是一个桶（桶相当于线性表，用于解决冲突），桶的大小应当是质数</p><p>哈希函数：</p><p><img src="/images/comp/com-prin6.assets/image-20200615162944658.png" alt="image-20200615162944658" style="zoom:67%;" /></p><p>α的一种合理的选择是2的幂，这样乘法可以通过移位来完成</p><h4 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h4><p>说明等价(declaration equivalence)：</p><p><img src="/images/comp/com-prin6.assets/image-20200615175632759.png" alt="image-20200615175632759" style="zoom: 50%;" /></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;属性文法&quot;&gt;&lt;a href=&quot;#属性文法&quot; class=&quot;headerlink&quot; title=&quot;属性文法&quot;&gt;&lt;/a&gt;属性文法&lt;/h2&gt;&lt;p&gt;如果X是一个文法符号，a是X的一个属性，那么我们把与X关联的a的值记作X.a&lt;/p&gt;
&lt;p&gt;在语法制导语义(syntax-d
      
    
    </summary>
    
      <category term="Notes" scheme="https://iris-cyy.github.io/categories/Notes/"/>
    
      <category term="Compilation Principle" scheme="https://iris-cyy.github.io/categories/Notes/Compilation-Principle/"/>
    
    
      <category term="Notes" scheme="https://iris-cyy.github.io/tags/Notes/"/>
    
      <category term="CP" scheme="https://iris-cyy.github.io/tags/CP/"/>
    
  </entry>
  
  <entry>
    <title>【Python】易错题</title>
    <link href="https://iris-cyy.github.io//Notes/Python/2020-06-15/python_qs/"/>
    <id>https://iris-cyy.github.io//Notes/Python/2020-06-15/python_qs/</id>
    <published>2020-06-15T01:56:51.000Z</published>
    <updated>2020-09-04T10:28:14.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python易错题"><a href="#Python易错题" class="headerlink" title="Python易错题"></a>Python易错题</h2><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><ul><li><p>高级语言程序要被机器执行,只有用解释器来解释执行。</p><p>F</p></li><li><p>已知 x等于3, 则 语句x=’3’是错误的。</p><blockquote><p>F</p><p>注意题目是x=’3’而不是x==’3’</p></blockquote></li><li><p>已知 x=3, 则执行“ x=7”后，id(x)的返回值与原来没有变化。</p><blockquote><p>F</p></blockquote></li><li><p><strong>__</strong>是不等长编码。</p><p>A. ASCII码</p><p>B. Unicode码</p><p><strong>C. UTF-8码</strong></p><p>D. 以上都不</p></li><li><p>输出str对应的utf-8编码</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(s.encode(<span class="string">"utf-8"</span>))</span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><ul><li><p>Python 语句 print(0xA + 0xB)的输出结果是__</p><blockquote><p>21</p></blockquote></li><li><p>Python 表达式 sqrt(4)*sqrt(9)的值为__</p><blockquote><p>6.0</p><p>sqrt类型为float</p><p>其实是math.sqrt()</p></blockquote></li><li><p>complex的实部虚部类型都是float，conjugate返回共轭复数</p></li><li><p>Python 表达式 3**2**3 的值为__</p><blockquote><p>6561</p><p>**的运算顺序从右往左，先算2**3</p></blockquote></li><li><p>round(18.67, -1) = 20.0 </p><blockquote><p>注意是float类型</p><p>round(18.67)是int类(18)，round(18.67, 0)是float类(18.0)</p></blockquote></li><li><p>int(“101”, 2) = 5</p><blockquote><p>二进制的101，转为十进制</p><p>注意引号</p></blockquote></li><li><p>Python输出 print(“hello” ‘world’)的结果是__</p><blockquote><p>helloworld</p></blockquote></li><li><p>0 and 2 -&gt; 0</p><p>1 and 2 -&gt; 2</p><p>3 and 2 and 5 -&gt; 5</p><p>3 and 0 and 5 -&gt; 0</p></li><li><p>32.2//6 -&gt; 5.0 (float)</p><p>32//6 -&gt; 5 (int)</p></li></ul><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><ul><li><p>列表可以用find()函数来搜索数据是否在列表中</p><blockquote><p>F</p></blockquote></li><li><p>将列表中的元素顺序打乱的函数shuffle()不是random模块的函数或方法</p><blockquote><p>F</p><p>random.shuffle(a)</p></blockquote></li><li><p>字符串对象和元组对象是不可变对象，列表对象为可变对象</p><blockquote><p>T</p></blockquote></li><li><p>lst=[12, -5, -22, -10, -26, 35, 0, 49, 3, -21]</p><p>lst[:100] -&gt; [12, -5, -22, -10, -26, 35, 0, 49, 3, -21]</p><p>lst[100:] -&gt; []</p><p>lst[100] -&gt; error</p></li><li><p>下面的程序当输入是<code>c d e a</code>时，输出是<code>a c d e</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = input().split(<span class="string">" "</span>)</span><br><span class="line">print(<span class="string">"After sorted:"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a.sort():    </span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><blockquote><p>error 因为a.sort()直接在原序列上排序，无返回值</p><p>a.replace() 有返回 原序列不变 -&gt; str</p><p>a.remove() 也在原序列上删除（但注意 只删除第一个）</p></blockquote></li><li><p>要想得到[0,100]范围内的随机数，random.randint(0,n)里的n应该是：</p><blockquote><p>100</p></blockquote></li></ul><h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><ul><li><p>带有else子句的异常处理结构，如果不发生异常则执行else子句中的代码</p><blockquote><p>T</p></blockquote></li><li><p>在异常处理结构中，不论是否发生异常，finally子句中的代码总是会执行的</p><blockquote><p>T</p></blockquote></li></ul><h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><ul><li><p>集合的元素可以是任意数据类型</p><blockquote><p>F</p><p>只能是不可变类型</p></blockquote></li><li><p>列表可以作为字典的键</p><blockquote><p>F</p><p>只能是不可变类型</p></blockquote></li><li><p>集合不能append，不能取下标</p></li></ul><h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><ul><li><p>print(type(lambda:3))的输出结果是__</p><blockquote><class 'function'></blockquote></li><li><p>在Python中，对于函数定义代码的理解，正确的理解是<strong>____</strong>。</p><p>A. 必须存在形参</p><p>B. 必须存在return语句</p><p>C. 形参和return语句都是可有可无的</p><p>D. 形参和return语句要么都存在，要么都不存在</p><blockquote><p>C</p></blockquote></li><li><p>在一个函数中如局部变量和全局变量同名，则__。</p><p>A. 局部变量屏蔽全局变量</p><p>B. 全局变量屏蔽局部变量</p><p>C. 全局变量和局部变量都不可用</p><p>D. 程序错误</p><blockquote><p>A</p></blockquote></li><li><p>函数可以改变哪种数据类型的实参？</p><p>A. int</p><p>B. string</p><p>C. list</p><p>D. float</p><blockquote><p>C</p></blockquote></li><li><p><code>`</code>python<br>def fun(x1,x2,x3,**x4):  </p><pre><code>print(x1,x2,x3,x4)</code></pre><p>fun(x1=1,x2=22,x3=333,x4=4444)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  &gt; 1 22 333 &#123;&#39;x4&#39;: 4444&#125;</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;python</span><br><span class="line">  def f1(a,b,c):</span><br><span class="line">       print(a+b)</span><br><span class="line">  nums&#x3D;(1,2,3)</span><br><span class="line">  f1(nums)</span><br></pre></td></tr></table></figure><blockquote><p>error</p></blockquote></li></ul><h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><ul><li><p>以”w”模式打开的文件无法进行读操作。</p><blockquote><p>T</p></blockquote></li><li><p>read函数返回的是列表。</p><blockquote><p>F</p></blockquote></li><li><p>readlines函数返回的是列表。</p><blockquote><p>T</p></blockquote></li></ul><h3 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h3><ul><li><p>在类定义中隐藏对象的细节称为实例化</p><blockquote><p>F</p></blockquote></li><li><p>对于Python类中的私有成员，可以通过<code>对象名._类名__私有成员名</code>的方式来访问</p><blockquote><p>T</p></blockquote></li><li><p>在面向对象程序设计中，函数和方法是完全一样的，都必须为所有参数进行传值</p><blockquote><p>F</p><p>self不用传值</p></blockquote></li><li><p>在Python中定义类时实例方法的第一个参数名称必须是self。</p><blockquote><p>F</p></blockquote></li><li><p>定义类时，在一个方法前面使用@classmethod进行修饰，则该方法属于类方法。</p><blockquote><p>T</p></blockquote></li><li><p>定义类时，在一个方法前面使用@staticmethod进行修饰，则该方法属于静态方法</p><blockquote><p>T</p></blockquote></li><li><p>在类中，具四个形式参数的方法通常在调用时有__个实际参数。</p><blockquote><p>3</p></blockquote></li><li><p>以下__不是面向对象程序设计的基本特征之一。</p><p>A. 继承</p><p>B. 多态</p><p>C. 抽象</p><p>D. 封装</p></li></ul><h3 id="期中"><a href="#期中" class="headerlink" title="期中"></a>期中</h3><ul><li><code>`</code>python<br>list1=[1,43]<br>list2=list1<br>list1[0]=22<br>print(list2[0])<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 22</span><br><span class="line">&gt;</span><br><span class="line">&gt; &#96;&#96;&#96;python</span><br><span class="line">&gt; b &#x3D; a #深拷贝</span><br><span class="line">&gt; c &#x3D; a[:] #浅拷贝</span><br><span class="line">&gt; c &#x3D; a.copy() #浅拷贝</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="样卷"><a href="#样卷" class="headerlink" title="样卷"></a>样卷</h3><ul><li><p><code>`</code>python<br>lst=[1,2,3]<br>lst1=lst.copy()<br>print(id(lst)==id(lst1))</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  &gt; False</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;python</span><br><span class="line">  lst&#x3D;[&#123;m:n&#125; for m in &#39;ABC&#39; for n in &#39;ABC&#39; if m!&#x3D;n]</span><br><span class="line">  print(lst)</span><br></pre></td></tr></table></figure><blockquote><p>[{‘A’: ‘B’}, {‘A’: ‘C’}, {‘B’: ‘A’}, {‘B’: ‘C’}, {‘C’: ‘A’}, {‘C’: ‘B’}]</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python易错题&quot;&gt;&lt;a href=&quot;#Python易错题&quot; class=&quot;headerlink&quot; title=&quot;Python易错题&quot;&gt;&lt;/a&gt;Python易错题&lt;/h2&gt;&lt;h3 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Notes" scheme="https://iris-cyy.github.io/categories/Notes/"/>
    
      <category term="Python" scheme="https://iris-cyy.github.io/categories/Notes/Python/"/>
    
    
      <category term="Notes" scheme="https://iris-cyy.github.io/tags/Notes/"/>
    
      <category term="Python" scheme="https://iris-cyy.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【Python】File</title>
    <link href="https://iris-cyy.github.io//Notes/Python/2020-06-01/python_file/"/>
    <id>https://iris-cyy.github.io//Notes/Python/2020-06-01/python_file/</id>
    <published>2020-06-01T08:29:11.000Z</published>
    <updated>2020-06-01T11:18:09.550Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/python/python-file.assets/image-20200601163017840.png" width=600></p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>file = open(filename, mode[…])</p><blockquote><p>open()函数至少两个参数，文件名可以是文件实际名字也可以是包含完整路径的名字</p><p>open()函数返回一个文件对象，使用该文件对象可以进行读写操作</p></blockquote><p><img src="/images/python/python-file.assets/image-20200601163510174.png" width=600></p><blockquote><p>eg. rt表示打开文本文件，rb表示打开二进制文件</p></blockquote><p>文本文件若用二进制形式打开，显示的是编码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = open(<span class="string">"test.py"</span>, <span class="string">"rt"</span>, encoding=<span class="string">"utf-8"</span>)</span><br></pre></td></tr></table></figure><p>如果文件名包含路径，比如D:\python\test.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file = open(<span class="string">r"D:\python\test.py"</span>, <span class="string">"r"</span>)</span><br><span class="line">file = open(<span class="string">"D:\\python\\test.py"</span>, <span class="string">"r"</span>)</span><br><span class="line">file = open(<span class="string">"D:/python/test.py"</span>, <span class="string">"r"</span>)</span><br><span class="line"><span class="comment">#不可以直接file = open("D:\python\test.py")，因为\会被当成转义字符</span></span><br></pre></td></tr></table></figure><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>file.close()</p><p>如果前面用的是with open则不用close()</p><h3 id="文件读写操作"><a href="#文件读写操作" class="headerlink" title="文件读写操作"></a>文件读写操作</h3><p>file为文件对象</p><p><img src="/images/python/python-file.assets/image-20200601164022922.png" width=600></p><p><img src="/images/python/python-file.assets/image-20200601164028828.png" width=620></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f = open(fname, w+) <span class="comment">#如果有文件则覆盖写，没有文件则创建</span></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">f.writelines(l)</span><br><span class="line">print(f.tell()) <span class="comment">#文件指针所在位置，这里是3（即文件末尾）</span></span><br><span class="line">f.seek(<span class="number">0</span>) <span class="comment">#把文件指针放回到开头位置</span></span><br><span class="line">print(f.tell()) <span class="comment">#输出0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">  print(line) <span class="comment">#输出123</span></span><br><span class="line"> f.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/python/python-file.assets/image-20200601163017840.png&quot; width=600&gt;&lt;/p&gt;
&lt;h3 id=&quot;打开文件&quot;&gt;&lt;a href=&quot;#打开文件&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Notes" scheme="https://iris-cyy.github.io/categories/Notes/"/>
    
      <category term="Python" scheme="https://iris-cyy.github.io/categories/Notes/Python/"/>
    
    
      <category term="Notes" scheme="https://iris-cyy.github.io/tags/Notes/"/>
    
      <category term="Python" scheme="https://iris-cyy.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【Python】Function</title>
    <link href="https://iris-cyy.github.io//Notes/Python/2020-05-07/python_func/"/>
    <id>https://iris-cyy.github.io//Notes/Python/2020-05-07/python_func/</id>
    <published>2020-05-07T02:41:40.000Z</published>
    <updated>2020-06-01T08:11:39.864Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> &lt;函数名&gt; <span class="params">(&lt;参数列表&gt;)</span>:</span></span><br><span class="line">&lt;函数体&gt;</span><br><span class="line"><span class="keyword">return</span> &lt;返回值列表&gt;</span><br></pre></td></tr></table></figure><ul><li><p>形参不需要声明类型，也不需要指定函数返回值类型</p></li><li><p>允许嵌套定义函数</p></li></ul><p>全局变量用global进行引用（否则默认新建局部变量）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">global</span> a</span><br><span class="line">  a = <span class="number">2</span></span><br><span class="line">  b = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">print(a, b) <span class="comment">#a = 2, b = 2</span></span><br></pre></td></tr></table></figure><p>但如果是列表，会改动外部全局的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">  l.append(<span class="number">6</span>)</span><br><span class="line">  print(l) <span class="comment">#[1,2,6]</span></span><br><span class="line">  </span><br><span class="line">print(l) <span class="comment">#[1,2,6]</span></span><br><span class="line">print(*l) <span class="comment">#1 2 6</span></span><br></pre></td></tr></table></figure><p>可以用默认的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b=<span class="number">2</span>)</span>:</span></span><br><span class="line">  ...</span><br><span class="line"><span class="comment"># 不给b传参时默认b=2</span></span><br></pre></td></tr></table></figure><p>形参带*表示任意数量的参数作为元组传入，带**表示任意数量的参数作为字典传入（一般放在最后一个参数位置）</p><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>id(a)：返回对象唯一标识符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">140260960941824</span></span><br></pre></td></tr></table></figure><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>type(a)：返回变量类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(a)</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h4><p>dir(a)：返回变量（数据类型、class等）可以调用的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(a)</span><br><span class="line">[<span class="string">'__abs__'</span>, <span class="string">'__add__'</span>, <span class="string">'__and__'</span>, <span class="string">'__class__'</span>, <span class="string">'__cmp__'</span>, <span class="string">'__coerce__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__div__'</span>, <span class="string">'__divmod__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__float__'</span>, <span class="string">'__floordiv__'</span>, <span class="string">'__format__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getnewargs__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__hex__'</span>, <span class="string">'__index__'</span>, <span class="string">'__init__'</span>, <span class="string">'__int__'</span>, <span class="string">'__invert__'</span>, <span class="string">'__long__'</span>, <span class="string">'__lshift__'</span>, <span class="string">'__mod__'</span>, <span class="string">'__mul__'</span>, <span class="string">'__neg__'</span>, <span class="string">'__new__'</span>, <span class="string">'__nonzero__'</span>, <span class="string">'__oct__'</span>, <span class="string">'__or__'</span>, <span class="string">'__pos__'</span>, <span class="string">'__pow__'</span>, <span class="string">'__radd__'</span>, <span class="string">'__rand__'</span>, <span class="string">'__rdiv__'</span>, <span class="string">'__rdivmod__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__rfloordiv__'</span>, <span class="string">'__rlshift__'</span>, <span class="string">'__rmod__'</span>, <span class="string">'__rmul__'</span>, <span class="string">'__ror__'</span>, <span class="string">'__rpow__'</span>, <span class="string">'__rrshift__'</span>, <span class="string">'__rshift__'</span>, <span class="string">'__rsub__'</span>, <span class="string">'__rtruediv__'</span>, <span class="string">'__rxor__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__sub__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__truediv__'</span>, <span class="string">'__trunc__'</span>, <span class="string">'__xor__'</span>, <span class="string">'bit_length'</span>, <span class="string">'conjugate'</span>, <span class="string">'denominator'</span>, <span class="string">'imag'</span>, <span class="string">'numerator'</span>, <span class="string">'real'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(list)</span><br><span class="line">[<span class="string">'__add__'</span>, <span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__delitem__'</span>, <span class="string">'__delslice__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getitem__'</span>, <span class="string">'__getslice__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__iadd__'</span>, <span class="string">'__imul__'</span>, <span class="string">'__init__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__le__'</span>, <span class="string">'__len__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__mul__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__reversed__'</span>, <span class="string">'__rmul__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__setitem__'</span>, <span class="string">'__setslice__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'append'</span>, <span class="string">'count'</span>, <span class="string">'extend'</span>, <span class="string">'index'</span>, <span class="string">'insert'</span>, <span class="string">'pop'</span>, <span class="string">'remove'</span>, <span class="string">'reverse'</span>, <span class="string">'sort'</span>]</span><br></pre></td></tr></table></figure><h4 id="del"><a href="#del" class="headerlink" title="del"></a>del</h4><p>del(a)：删除变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span>(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'a'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p>sorted(iterable[, key[, reverse]])</p><blockquote><p>iterable：序列，如字符串、列表、元组等</p><p>key：用来进行比较的元素</p><p>reverse：排序规则，True降序，False升序（默认）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(a)</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="comment">#不变</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'a'</span>:<span class="number">90</span>, <span class="string">'c'</span>:<span class="number">100</span>, <span class="string">'b'</span>:<span class="number">80</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(d)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(d.values())</span><br><span class="line">[<span class="number">80</span>, <span class="number">90</span>, <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(d.items())</span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">90</span>), (<span class="string">'b'</span>, <span class="number">80</span>), (<span class="string">'c'</span>, <span class="number">100</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(d.items(), key = <span class="keyword">lambda</span> x : x[<span class="number">1</span>])</span><br><span class="line">[(<span class="string">'b'</span>, <span class="number">80</span>), (<span class="string">'a'</span>, <span class="number">90</span>), (<span class="string">'c'</span>, <span class="number">100</span>)]</span><br></pre></td></tr></table></figure><p>lambda 匿名函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x : x*x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">5</span>)</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>根据提供的函数对指定序列做映射</p><p>map(function, iterable, …)</p><blockquote><p>function：以参数序列中的每一个元素调用function函数</p><p>iterable：序列，返回包含每次function函数返回值的新列表或迭代器</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = list(map(<span class="keyword">lambda</span> x : x*x, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]))</span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>]</span><br></pre></td></tr></table></figure><h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><p>将可迭代的对象作为参数，将对象中对应的元素打包成元组，然后返回由元组组成的列表或迭代器。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同</p><p>zip([iterable, …])</p><blockquote><p>iterable：一个或多个序列</p><p>返回值：返回元组列表</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(a,b))</span><br><span class="line">[(<span class="number">1</span>,<span class="number">5</span>), (<span class="number">2</span>,<span class="number">6</span>), (<span class="number">3</span>,<span class="number">7</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(zip(a,b))</span><br><span class="line">&#123;<span class="number">1</span>:<span class="number">5</span>, <span class="number">2</span>:<span class="number">6</span>, <span class="number">3</span>:<span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>执行字符串表达式，并返回表达式的值</p><p>eval(expression[, globals[, locals]])</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">'x+3*y'</span>)</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p>与eval类似，执行动态语句，不同的是其主要用于执行语句块</p><p>exec(object[, globals[, locals]])</p><h4 id="all"><a href="#all" class="headerlink" title="all"></a>all</h4><p>判断给定的可迭代参数</p><p>all(iterable)</p><p>如果iterable中所有元素都为true则返回true，否则返回false</p><p>元素除了0、空、None、False外全算True</p><p>空列表、空元组返回值为True</p><h4 id="any"><a href="#any" class="headerlink" title="any"></a>any</h4><p>any(iterable)</p><p>有一个为True则返回True，全为False则返回False</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Notes" scheme="https://iris-cyy.github.io/categories/Notes/"/>
    
      <category term="Python" scheme="https://iris-cyy.github.io/categories/Notes/Python/"/>
    
    
      <category term="Notes" scheme="https://iris-cyy.github.io/tags/Notes/"/>
    
      <category term="Python" scheme="https://iris-cyy.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【Python】Exception</title>
    <link href="https://iris-cyy.github.io//Notes/Python/2020-04-14/py_except/"/>
    <id>https://iris-cyy.github.io//Notes/Python/2020-04-14/py_except/</id>
    <published>2020-04-14T13:54:48.000Z</published>
    <updated>2020-04-14T13:58:15.629Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">     语句块<span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> 异常类型<span class="number">1</span>:</span><br><span class="line">     语句块<span class="number">2</span></span><br><span class="line"><span class="keyword">except</span> 异常类型<span class="number">2</span>:</span><br><span class="line">     语句块<span class="number">3</span> </span><br><span class="line">…</span><br><span class="line"><span class="keyword">except</span> 异常类型N:</span><br><span class="line">     语句块N+<span class="number">1</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">     语句块N+<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">     语句块N+<span class="number">3</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">     语句块N+<span class="number">4</span></span><br></pre></td></tr></table></figure><p><img src="/images/python/python-exception.assets/image-20200414151836418.png" width=600></p><ul><li>正常程序在语句块1中执行。</li><li>如果程序执行中发生异常，中止程序运行，跳转到所对应的异常处理块中执行。</li><li>在“except 异常类型 ”语句中找对应的异常类型，如果找到的话，执行后面的语句块。</li><li>如果找不到，则执行“except”后面的语句块N+2。</li><li>如果程序正常执行没有发生异常，则继续执行else后的语句块N+3。</li><li>无论异常是否发生，最后都执行finally后面语句块N+4。</li></ul><p><img src="/images/python/python-exception.assets/image-20200414152034678.png" alt="image-20200414152034678"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Notes" scheme="https://iris-cyy.github.io/categories/Notes/"/>
    
      <category term="Python" scheme="https://iris-cyy.github.io/categories/Notes/Python/"/>
    
    
      <category term="Notes" scheme="https://iris-cyy.github.io/tags/Notes/"/>
    
      <category term="Python" scheme="https://iris-cyy.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【Compilation Principle】Bottom-Up Parsing</title>
    <link href="https://iris-cyy.github.io//Notes/Compilation-Principle/2020-04-14/cp_bottomup/"/>
    <id>https://iris-cyy.github.io//Notes/Compilation-Principle/2020-04-14/cp_bottomup/</id>
    <published>2020-04-14T07:23:20.000Z</published>
    <updated>2020-04-21T13:08:53.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>自底向上的分析程序使用了显式栈来完成分析，分析栈包括记号和非终结符</p><p>分析能力：LR(0) &gt; LALR(1) &gt; SLR(1) &gt; LR(0)</p><h3 id="Right-most-derivation"><a href="#Right-most-derivation" class="headerlink" title="Right-most derivation"></a>Right-most derivation</h3><p>Start with the tokens, end with the start symbol (backward)</p><p><img src="/images/comp/com-prin5.assets/image-20200420100748671.png" alt="image-20200420100748671" style="zoom: 50%;" /></p><h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p><strong>Shift</strong>: shift a terminal from the front of the input to the top of the stack.</p><p><strong>Reduce</strong>: reduce a string α at the top of the stack to a nonterminal A, given the BNF choice A→α</p><p>自底向上的分析程序的另一个特征是：出于技术原因，总是将文法与一个新的开始符号一同扩充。若S是开始符号，那么就将新的开始符号S’增加到文法中，同时还添加一个单元产生式到前面的开始符号中：S’ → S</p><blockquote><p>E’ → E<br>E → E + n | n</p><p><img src="/images/comp/com-prin5.assets/image-20200420101319721.png" alt="image-20200420101319721"></p></blockquote><h3 id="Right-Sentential-Form"><a href="#Right-Sentential-Form" class="headerlink" title="Right Sentential Form"></a>Right Sentential Form</h3><ul><li><p>Each of the intermediate strings of terminals and non-terminals in such a derivation is called a right sentential form. </p></li><li><p>Each such sentential form is split between the parsing stack and the input during a shift-reduce parse.</p></li></ul><h3 id="Viable-Prefixes"><a href="#Viable-Prefixes" class="headerlink" title="Viable Prefixes"></a>Viable Prefixes</h3><p>The sequence of symbols on the parsing stack is called <strong>a viable prefix</strong> of the right sentential form.</p><ul><li><p>E, E+ ,and E+n are all <strong>viable prefixes</strong> of the right sentential form E+n. </p></li><li><p>The right sentential form n+n has ε and n as its viable prefix. </p></li><li><p>That n+ is not a viable prefix of n+n.（因为n进栈时，栈中的n+应该已经变成了E+）</p></li></ul><h3 id="Handle"><a href="#Handle" class="headerlink" title="Handle"></a>Handle</h3><p>This string, together with the position in the right sentential form where it occurs, and the production used to reduce it, is called the handle of the right sentential form.</p><p><strong>Determining the next handle in a parse is the main task of a shift-reduce parser.</strong></p><p>Example, in step 3 of Table 5.1 a reduction by S→ε could be performed. The resulting string (SS) is not a right sentential form, thus ε is not the handle at this position in the sentential form (S . </p><p><br></p><h2 id="LR-0-Items-and-LR-0-Parsing"><a href="#LR-0-Items-and-LR-0-Parsing" class="headerlink" title="LR(0) Items and LR(0) Parsing"></a>LR(0) Items and LR(0) Parsing</h2><p><strong>L</strong>eft-to-right</p><p><strong>R</strong>ightmost</p><p>An LR(0) item of a context-free grammar: a production choice with a distinguished position in its right-hand side.  使用 · 来表示区分的位置，·前表示分析栈，·后表示输入串（If A → α ,  β γ = α,  then A → β·γ  is an LR(0) item） </p><blockquote><p>E → E′<br>E → E+n|n</p><p>LR(0) items:<br>E′ → ⋅E<br>E′ → E⋅<br>E → ⋅E+n<br>E → E⋅+n<br>E → E+⋅n<br>E → E+n⋅<br>E → ⋅n<br>E → n⋅</p></blockquote><h3 id="DFA-of-LR-0-items"><a href="#DFA-of-LR-0-items" class="headerlink" title="DFA of LR(0) items"></a>DFA of LR(0) items</h3><p>If X is a token or a nonterminal, the item can be written as A → α·Xη</p><p><img src="/images/comp/com-prin5.assets/image-20200420110557549.png" alt="image-20200420110557549" style="zoom:67%;" /></p><p>If X is a token, then this transition corresponds to a shift of X from the input to the top of the stack during a parse. </p><p>If X is a nonterminal, X will never appear as an input symbol. (such a transition will still correspond to the pushing of <em>X</em> onto the stack during a parse, but this can only occur during a reduction by a production X → β. )</p><p><img src="/images/comp/com-prin5.assets/image-20200420110711936.png" alt="image-20200420110711936" style="zoom: 67%;" /></p><p>注意：根据LR(0) items生成的DFA不一定满足LR(0)文法</p><blockquote><p>E′ → ⋅E<br>E′ → E⋅<br>E → ⋅E+n<br>E → E⋅+n<br>E → E+⋅n<br>E → E+n⋅<br>E → ⋅n<br>E → n⋅</p><p>NFA:</p><p><img src="/images/comp/com-prin5.assets/image-20200420111031202.png" alt="image-20200420111031202" style="zoom:80%;" /></p><p>DFA:</p><p><img src="/images/comp/com-prin5.assets/image-20200420111049654.png" alt="image-20200420111049654" style="zoom: 67%;" /></p></blockquote><h3 id="LR-0-Parsing-Algorithm"><a href="#LR-0-Parsing-Algorithm" class="headerlink" title="LR(0) Parsing Algorithm"></a>LR(0) Parsing Algorithm</h3><p>分析栈中存储符号和DFA状态的编号，在向分析栈中push入符号之后要push入DFA状态的编号</p><p><img src="/images/comp/com-prin5.assets/image-20200420111742765.png" alt="image-20200420111742765" style="zoom:67%;" /></p><p>Definition:</p><p>Let s be the current state (at the top of the parsing stack).Then actions are defined as follows:</p><ol><li><p>If state s contains any item of the form A → α·Xβ (X is a terminal). Then the action is to <strong>shift</strong> the current input token on to the stack.</p></li><li><p>If state s contains any <strong>complete item</strong> (an item of the form A → γ·), then the action is to reduce by the rule A → γ·</p><ul><li><p>A <strong>reduction</strong> by the rule S’→ S, where S’ is the start state, </p></li><li><p><strong>Acceptance</strong> if  the input is empty</p></li><li><p><strong>Error</strong> if the input is not empty. </p></li></ul></li></ol><p>A grammar is said to be LR(0) grammar if the above rules are unambiguous. </p><p>A grammar is LR(0) if and only if </p><ul><li><p>Each state is a shift state (a state containing only “shift” items) （不含有shift-reduce冲突）</p></li><li><p>A reduce state containing a single complete item. （不含有reduce-reduce冲突）</p></li></ul><h4 id="Parsing-Table"><a href="#Parsing-Table" class="headerlink" title="Parsing Table"></a>Parsing Table</h4><p><img src="/images/comp/com-prin5.assets/image-20200420113236597.png" alt="image-20200420113236597" style="zoom: 50%;" /></p><p>简略版：用s表示shift，r表示reduce，数字表示状态编号</p><p><img src="/images/comp/com-prin5.assets/image-20200420113254413.png" alt="image-20200420113254413" style="zoom:50%;" /></p><p><br></p><h2 id="SLR-1-Parsing"><a href="#SLR-1-Parsing" class="headerlink" title="SLR(1) Parsing"></a>SLR(1) Parsing</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><ol><li>If state s contains any item of form A → α·Xβ, then the action is to <strong>shift</strong> the current input token onto the stack, and the new state to be pushed on the stack is the state containing the item A→ αX·β.</li><li>If state s contains the complete item A → γ·, and the next token in the input string is in <u>Follow(A)</u>, then the action is to <strong>reduce</strong> by the rule A → γ.<ul><li>A reduction by the rule S’ →S, where S’ is the start state, this will happen <strong>only if the next input token is \$</strong>. （<strong>accept</strong>）</li><li>Remove the string γ and all of its corresponding states from the parsing stack.</li><li>Back up in the DFA to the state from which the construction of γ began.</li><li>This state must contain an item of the form B→α·Aβ. Push A onto the stack, and push the state containing the item B → αA·β.</li></ul></li><li>If the next input token is such that neither of the above two cases applies, an <strong>error</strong> is declared.</li></ol><h4 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h4><p>A grammar is an SLR(l) grammar: the SLR(1) parsing rules results in no ambiguity.</p><p>A grammar is SLR(1) <strong>if and only if</strong>, for any state s, the following two conditions are satisfied:<br>（在LR(0)前提下进行放宽）</p><ol><li>For any item A → α·Xβ in s with X a terminal, there is no complete item B→ γ. in s with X in Follow(B). (shift-reduce conflict)</li><li>For any two complete items A → α·and B →β· in s, Follow(A) ∩ Follow(B) is empty. (reduce-reduce conflict)</li></ol><blockquote><p><img src="/images/comp/com-prin5.assets/image-20200421103711570.png" alt="image-20200421103711570" style="zoom:50%;" /></p><p>This grammar is not LR(0), but it is SLR(1).  </p><p>对于LR(0)来说，state1有shift-reduce歧义。但对于SLR(1)来说，看Follow set来判断是否有歧义。</p><p>Follow(E’) ={\$}, Follow(E) = {\$, +}</p><p>因为+不在Follow(E’)中，可以根据input来判断这个state走哪条规则，因此没有歧义（如果+在Follow(E’)中则会有歧义）</p></blockquote><h4 id="Disambiguating-Rules"><a href="#Disambiguating-Rules" class="headerlink" title="Disambiguating Rules"></a>Disambiguating Rules</h4><ul><li>(shift-reduce) Always prefer the shift over the reduce</li><li>(reduce-reduce) Always prefer the first reduce rule (一般认为reduce-reduce conflict为error)</li></ul><p><br></p><h2 id="LR-1-Parsing"><a href="#LR-1-Parsing" class="headerlink" title="LR(1) Parsing"></a>LR(1) Parsing</h2><h3 id="LR-1-items"><a href="#LR-1-items" class="headerlink" title="LR(1) items"></a>LR(1) items</h3><p>将lookahead加入到item和DFA中（LR(1)项应是由L R ( 0 )项和一个先行记号组成的对）</p><p>[A → α·β, a] (A → αβ is an LR(0) item and a is a token (lookahead), 只有当下一个input是a时才进行这一步对应的操作) </p><p>The start symbol of the NFA of LR(1) items becomes the item [S’ → ·S, $].</p><p>The major difference between the LR(0) and LR(1) automata: Definition of the ε-transitions.</p><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Given an LR(1) item [A→α·Xγ,a], where X is any symbol (terminal or non-terminal), there is a transition<br>on X to the item [A→ αX·γ,a] </li><li>Given an LR(1) item [A→α·Bγ,a], where B is a nonterminal, there are ε-transitions to items [B→·β,b]<br>for every production B →β and for every token b in First(γa).</li></ul><blockquote><p>A → (A) | a</p><p>DFA：</p><p><img src="/images/comp/com-prin5.assets/image-20200421155123189.png" alt="image-20200421155123189" style="zoom: 50%;" /></p></blockquote><h3 id="The-General-parsing-algorithm"><a href="#The-General-parsing-algorithm" class="headerlink" title="The General parsing algorithm"></a>The General parsing algorithm</h3><p>Let s be the current state (a the top of the parsing stack). Then actions are defined as follows:</p><ol><li>If state s: any LR(1) item of the form [A→α·Xβ,a], X is a terminal, and X is the next token in the input string, <strong>shift</strong></li><li>If state s : the complete LR(1) item [A→α·,a] , the next token in the input string is a, <strong>reduce</strong></li><li>If the next input token is such that neither of the above two cases applies, an <strong>error</strong> is declared.</li></ol><blockquote><p>(1) A→(A) (2) A→a</p><p><img src="/images/comp/com-prin5.assets/image-20200421155700533.png" alt="image-20200421155700533" style="zoom:50%;" /></p></blockquote><h3 id="判定-1"><a href="#判定-1" class="headerlink" title="判定"></a>判定</h3><p>A grammar is an LR(1) grammar: If the application of the above general LR( l ) parsing rules results in no ambiguity.</p><p>A grammar is LR(1) if and only if, for any state s, the following two conditions are satisfied:</p><ol><li><p>For any item [A→α·Xβ,a] in s with X a terminal, there is no item in s of the form [B→γ·,X] (otherwise there is a <strong>shift-reduce</strong> conflict).</p></li><li><p>There are no two items in s of the form [A→α·, a] and [B→β·,a] (otherwise, there is a <strong>reduce-reduce</strong> conflict).</p></li></ol><p><br></p><h2 id="LALR-1-Parsing"><a href="#LALR-1-Parsing" class="headerlink" title="LALR(1) Parsing"></a>LALR(1) Parsing</h2><p>在LR(1)的基础上进行合并，preserving the smaller size of the DFA  of LR(0) items</p><ul><li>The core of a state of the DFA of LR(1) items is a state of the DFA of LR(0) items</li><li>Given two states s1 and s2 of the DFA of LR(l) items that have the same core, suppose there is a transition on the symbol X from s1 to a state t1. Then there is also a transition on X from state s2 to a state t2, and the states t1 and t2 have the same core.</li></ul><blockquote><p>(1) A→(A) (2) A→a</p><p><img src="/images/comp/com-prin5.assets/image-20200421160031845.png" alt="image-20200421160031845" style="zoom: 50%;" /></p></blockquote><p>A grammar is an LALR(l) grammar if no parsing conflicts arise in the LALR( l) parsing algorithm.</p><p>If a grammar is LR(l), then the LALR(l) parsing table cannot have any shift-reduce conflicts, there may be <strong>reduce-reduce conflicts</strong>.</p><p><img src="/images/comp/com-prin5.assets/image-20200421160238005.png" alt="image-20200421160238005" style="zoom:50%;" /></p><p>If a grammar is SLR(l), then it certainly is LALR(l)</p><p>LALR(1) parsers often do as well as general LR(1) parsers in removing typical conflicts that occur in SLR(l) parsing.</p><p><br></p><h2 id="Error-Recovery"><a href="#Error-Recovery" class="headerlink" title="Error Recovery"></a>Error Recovery</h2><p>A bottom-up parser will detect an error when a blank (or error) entry is detected in the parsing table.</p><p>Errors should be detected as soon as possible.</p><p>This goal conflicts with an equally important one: reducing the size of the parsing table.</p><p>An LR(1) parser can, for example, detect errors earlier than an LALR(1) or SLR(1) parser, and these latter can detect errors earlier than an LR(0) parser.</p><p>A good error recovery in bottom-up parsers: removing symbol from either the parsing stack or the input or both.</p><p>There are three possible alternative actions:</p><ol><li><p><strong>Pop</strong> a state from the stack.</p></li><li><p>Successively pop tokens from the input until a token is seen for which we can restart the parse.</p></li><li><strong>Push</strong> a new state onto the stack.</li></ol><p>When an error occurs is as follows:</p><ol><li><p><strong>Pop</strong> states from the parsing stack until a state is found with nonempty Goto entries.</p></li><li><p>If there is a legal action on the current input token from one of the Goto states, <strong>push</strong> that state onto the stack and restart the parse.</p></li><li>If there is no legal action on the current input token from one of the Goto states, <strong>advance</strong> the input.</li></ol><p>There are several possible solutions (infinite loop)</p><ol><li>Insist on a <strong>shift</strong> action from a Goto state in step 2. （too restrictive ）</li><li>If the next legal move is a reduction, to set a flag that causes the parser to keep track of the sequence of states during the following reductions</li><li>If the same state recurs, to pop stack states until the original state is removed.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;p&gt;自底向上的分析程序使用了显式栈来完成分析，分析栈包括记号和非终结符&lt;/p&gt;
&lt;p&gt;分析能力：
      
    
    </summary>
    
      <category term="Notes" scheme="https://iris-cyy.github.io/categories/Notes/"/>
    
      <category term="Compilation Principle" scheme="https://iris-cyy.github.io/categories/Notes/Compilation-Principle/"/>
    
    
      <category term="Notes" scheme="https://iris-cyy.github.io/tags/Notes/"/>
    
      <category term="CP" scheme="https://iris-cyy.github.io/tags/CP/"/>
    
  </entry>
  
  <entry>
    <title>【Python】Library</title>
    <link href="https://iris-cyy.github.io//Notes/Python/2020-04-13/py_library/"/>
    <id>https://iris-cyy.github.io//Notes/Python/2020-04-13/py_library/</id>
    <published>2020-04-13T10:35:45.000Z</published>
    <updated>2020-06-01T11:17:46.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><p>random库，用于生成伪随机数</p><p><img src="/images/python/python-library.assets/QQ20200413-0.png" alt="QQ20200413-0"></p><h2 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h2><p>绘图/可视化（仿matlab）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">y = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 绘制以x为横坐标，y为纵坐标的折线图</span></span><br></pre></td></tr></table></figure><p>绘制y=x^2和y=x的图形</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.axis(<span class="string">"scaled"</span>)</span><br><span class="line">plt.xlim(<span class="number">0</span>,<span class="number">1</span>) <span class="comment"># x显示的范围</span></span><br><span class="line">plt.ylim(<span class="number">0</span>,<span class="number">1</span>) <span class="comment"># y显示的范围</span></span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">X1 = []</span><br><span class="line">Y1 = []</span><br><span class="line">Y2 = []</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> x&lt;=<span class="number">1</span>:</span><br><span class="line">  X1.append(x)</span><br><span class="line">  Y1.append(x)</span><br><span class="line">  Y2.append(x * x)</span><br><span class="line">plt.plot(X1, Y1)</span><br><span class="line"><span class="comment"># plt.plot(X1, Y1, color="red") 把线的颜色改成红色</span></span><br><span class="line">plt.plot(X1, Y2)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sinY = []</span><br><span class="line">cosY = []</span><br><span class="line">trigX = []</span><br><span class="line">angle = <span class="number">-180</span></span><br><span class="line"><span class="keyword">while</span> angle &lt;= <span class="number">180</span>:</span><br><span class="line">  x = math.pi / <span class="number">180</span> * angle</span><br><span class="line">  trigX.append(x)</span><br><span class="line">  y = math.sin(x)</span><br><span class="line">  sinY.append(y)</span><br><span class="line">  y = math.cos(x)</span><br><span class="line">  cosY.append(y)</span><br><span class="line">  angle = angle + <span class="number">10</span></span><br><span class="line"></span><br><span class="line">plt.scatter(trigX, sinY) <span class="comment">#散点图</span></span><br><span class="line">plt.scatter(trigX, cosY)</span><br><span class="line">plt.title(<span class="string">"..."</span>) <span class="comment">#标题</span></span><br><span class="line">plt.legend([<span class="string">"sin(x)"</span>, <span class="string">"cos(x)"</span>]) <span class="comment">#图例</span></span><br><span class="line">plt.grid(<span class="literal">True</span>) <span class="comment">#网格线</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t = np.arrange(<span class="number">-1</span>, <span class="number">3</span>, <span class="number">.01</span>) <span class="comment">#间隔0.01</span></span><br><span class="line">s = np.sin(<span class="number">2</span> * np.pi * t)</span><br><span class="line">c = np.cos(<span class="number">2</span> * np.pi * t)</span><br><span class="line">plt.plot(t, s)</span><br><span class="line">plt.plot(t, c)</span><br><span class="line"></span><br><span class="line">plt.axis([<span class="number">-1</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">2</span>])</span><br><span class="line">....</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.pause(<span class="number">0.1</span>) <span class="comment"># 动态绘制（停顿0.1s）</span></span><br></pre></td></tr></table></figure><h2 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h2><p>提供python运行环境的变量和函数</p><p><img src="/images/python/python-library.assets/image-20200601162002653.png" alt="image-20200601162002653"></p><p>不使用input()向程序输入值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.argv[<span class="number">0</span>] <span class="comment"># 程序的文件名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.argv[<span class="number">1</span>] <span class="comment"># 第一个参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.argv[<span class="number">2</span>] <span class="comment"># 第二个参数</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.argv[<span class="number">3</span>] <span class="comment"># 第n个参数</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.argv[<span class="number">0</span>])</span><br><span class="line">print(sys.argv[<span class="number">1</span>])</span><br><span class="line">print(sys.argv[<span class="number">2</span>])</span><br><span class="line">print(int(sys.argv[<span class="number">1</span>]) * int(sys.argv[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><p><img src="/images/python/python-library.assets/image-20200601162500809.png" width=500></p><p>标准输入输出：</p><p>sys.stdin</p><p>sys.stdout</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = sys.stdin.readlines() <span class="comment">#标准输入，完成多行输入</span></span><br><span class="line">sys.stdout.write(<span class="string">"abc"</span>) <span class="comment">#标准输出，和print的差别在于不会自己在末尾换行</span></span><br><span class="line"><span class="comment">#sys.stdout.write("abc"+"\n")等同于print("abc")</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;random&quot;&gt;&lt;a href=&quot;#random&quot; class=&quot;headerlink&quot; title=&quot;random&quot;&gt;&lt;/a&gt;random&lt;/h2&gt;&lt;p&gt;random库，用于生成伪随机数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/python/pytho
      
    
    </summary>
    
      <category term="Notes" scheme="https://iris-cyy.github.io/categories/Notes/"/>
    
      <category term="Python" scheme="https://iris-cyy.github.io/categories/Notes/Python/"/>
    
    
      <category term="Notes" scheme="https://iris-cyy.github.io/tags/Notes/"/>
    
      <category term="Python" scheme="https://iris-cyy.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【Compilation Principle】 Top-Down Parsing</title>
    <link href="https://iris-cyy.github.io//Notes/Compilation-Principle/2020-03-30/cp_topdown/"/>
    <id>https://iris-cyy.github.io//Notes/Compilation-Principle/2020-03-30/cp_topdown/</id>
    <published>2020-03-30T03:19:55.000Z</published>
    <updated>2020-05-17T12:22:17.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Recursive-Descent"><a href="#Recursive-Descent" class="headerlink" title="Recursive-Descent"></a>Recursive-Descent</h2><ul><li><p>不能出现左递归or间接左递归（因为左递归可能会造成无限循环）</p><blockquote><p>左递归：A → A a | …</p><p>间接左递归：A → B b | ..  ,  B → A a | …</p></blockquote></li><li><p>BNF要被扩展为EBNF</p><blockquote><p>eg. expr → expr addop term | term</p><p>EBNF: expr → term {addop term}</p></blockquote></li></ul><h3 id="文法改造——消除左递归-提取左因子"><a href="#文法改造——消除左递归-提取左因子" class="headerlink" title="文法改造——消除左递归 / 提取左因子"></a>文法改造——消除左递归 / 提取左因子</h3><h4 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h4><h5 id="Case-1-simple-immediate-left-recursion"><a href="#Case-1-simple-immediate-left-recursion" class="headerlink" title="Case 1:  simple immediate left recursion"></a>Case 1:  simple immediate left recursion</h5><p>​    $A → Aα|β$</p><p>  Rewrite:</p><p>​    $A → βA′$</p><p>​    $A′ → αA′|ε$</p><h5 id="Case-2-general-immediate-left-recursion"><a href="#Case-2-general-immediate-left-recursion" class="headerlink" title="Case 2:  general immediate left recursion"></a>Case 2:  general immediate left recursion</h5><p>​    $A→Aα_1|Aα_2|⋯|Aα_n|β_1|β_2|⋯|β_m$</p><p>  Rewrite:</p><p>​    $A→β_1A′|β_2A′|⋯|β_mA′$</p><p>​    $A′→α_1A′|α_2A′|⋯|α_nA′|ε$</p><h5 id="Case-3-general-left-recursion"><a href="#Case-3-general-left-recursion" class="headerlink" title="Case 3:  general left recursion"></a>Case 3:  general left recursion</h5><p>这里描述的算法仅是指不带有产生式且不带有循环的文法（其中循环是至少有一步是以相同的非终结符：$A \Rightarrow \alpha \Rightarrow^* A$开始和结束的推导。循环几乎肯定能导致分析程序进入无穷循环，而且带有循环的文法从不作为程序设计语言文法出现。程序设计语言文法确实是有产生式，但这经常是在非常有限的格式中，所以这个算法对于这些文法也几乎总是有效的。</p><p>该算法的方法是：为语言的所有非终结符选择任意顺序，如$A_1 , … , A_m$，接着再消除不增加$A_i’ $索引的所有左递归。它消除所有$A_i→A_j \gamma$，其中$j≤i$形式的规则。如果按这样操作从1到m的每一个i，则由于这样的循环的每个步骤只增加索引，且不能再次到达原始索引，因此就不会留下任何递归循环了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i:&#x3D;1 to m do </span><br><span class="line">for j:&#x3D;1 to i-1 do</span><br><span class="line">replace each grammar rule choice of the form Ai→ Ajβ by the rule   </span><br><span class="line">Ai→α1β|α2β| … |αkβ, where Aj→α1|α2| … |αk is the current rule for Aj.</span><br><span class="line">remove, if necessary, immediate left recursion involving Ai</span><br></pre></td></tr></table></figure><blockquote><p>eg.</p><p>A → B a | A a | c<br>B → B b | A b | d</p><ol><li><p>remove the immediate left recursion of  A<br>A → B a A’ | c A’<br>A’ → a A’ | ε<br>B → B b | A b| d</p></li><li><p>eliminate B → Ab by replacing A with its choices</p><p>A → B a A’ | c A’<br>A’ → a A’ | ε<br>B → B b | B a A‘ b | c A’ b | d</p></li><li><p>remove the immediate left recursion of B</p><p>A → B a A’ | c A’<br>A’ → a A’ | ε<br>B → c A’ b B’ | d B’<br>B’ → b B’ | a A’ b B’ | ε</p></li></ol></blockquote><h4 id="提取左因子"><a href="#提取左因子" class="headerlink" title="提取左因子"></a>提取左因子</h4><p>当两个或更多文法规则选择共享一个通用前缀串时，需要提取左因子（因为lookahead是1的时候如果有两条产生式将不知道应该走哪条。</p><p>如 A → αβ|αγ  $\Rightarrow$ A → α A’,  A’ → β|γ </p><blockquote><p>if-stmt → if (exp) statement | if (exp) statement else statement</p><p>在这个文法中，提取了左因子的格式是</p><p>​    if-stmt → if (exp) statement else-part<br>​    else-part → else statement | ε</p></blockquote><p><br></p><h2 id="LL-1-Parsing"><a href="#LL-1-Parsing" class="headerlink" title="LL(1) Parsing"></a>LL(1) Parsing</h2><p>from <strong>L</strong>eft to right</p><p><strong>L</strong>eft-most</p><p>look-ahead: <strong>1</strong> symbol (top-down必须至少look-ahead一个字符)</p><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>如果一个文法的LL(1)分析表中每一项最多只有一个产生式，则该文法是LL(1)文法（LL(1)文法不能有歧义）</p><h3 id="Basic-method"><a href="#Basic-method" class="headerlink" title="Basic method"></a>Basic method</h3><h4 id="Two-actions"><a href="#Two-actions" class="headerlink" title="Two actions"></a>Two actions</h4><ul><li><strong>Generate</strong>：当分析栈顶是非终结符时，用文法$ A \rightarrow α$ 将A替换成α（注意：倒序进栈）</li><li><p><strong>Match</strong>：栈顶是终结符时，将栈顶的符号和输入符号进行匹配</p></li><li><p>当分析栈和输入都为空时可以执行accept（代表文法分析顺利结束）</p></li><li><p>$ 表示栈底 / end of input</p></li></ul><h4 id="Parsing-table"><a href="#Parsing-table" class="headerlink" title="Parsing table"></a>Parsing table</h4><ul><li><p>由非终结符和终结符索引的二维数组，其中非终结符和终结符包括了要在恰当的分析步骤（包括代表输入结束的$）中使用的产生式选择。</p></li><li><p>这个表被称为$M[N, T]​$，这里的$N​$是文法的非终结符的集合，放在表格的纵向， $T​$是终结符或记号的集合（不包含ε），放在表格的横向（$表示结束状态）。</p></li><li><p>空项表明一个潜在的错误</p></li></ul><p><strong>构建分析表的规则：</strong></p><ul><li>如果$A→α​$是一个产生式选择，且有推导$\alpha \Rightarrow^* a \beta​$ 成立，其中 $α​$ 是一个记号，则将$A→α​$添加到表项目$M [A, a] ​$中。（First规则，根据可能出现的第一个终结符填表，在输入中给出了记号α，若α可为匹配生成一个a，则希望挑选规则A→α）</li><li>如果$A \rightarrow \alpha$是一个产生式选择，且有推导$\alpha \Rightarrow^* ε$和 $S \,\$ \Rightarrow^* \beta A a \gamma$ 成立，其中$S$是开始符号，$a$是一个记号（或\$），则将$A→\alpha$添加到表项目$M [A, a]$中。（Follow规则，根据下一个可能出现的终结符填表，若A派生了空串（通过A→α），且如a 是一个在推导中可合法地出现在A之后的记号，则要挑选A→α以使A消失）</li></ul><blockquote><p>以 S -&gt; (S)S|ε 为例，分析过程如下表所示：（Parsing表示分析栈中内容，Input表示输入内容）</p><p><img src="/images/comp/com-prin4.assets/image-20200414171109629.png" alt="image-20200414171109629" style="zoom: 67%;" /></p><p>Parsing Table</p><p><img src="/images/comp/com-prin4.assets/image-20200414171158493.png" alt="image-20200414171158493" style="zoom:67%;" /></p></blockquote><p>A parsing algorithm using the LL(1) parsing table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">push the start symbol onto the top the parsing stack;</span><br><span class="line">while the top of the parsing stack !&#x3D; $ and the next   </span><br><span class="line">     input token !&#x3D; $ do</span><br><span class="line">    if the top of the parsing stack is terminal a </span><br><span class="line">      and the next input token &#x3D; a</span><br><span class="line">    then (* match *)</span><br><span class="line">         pop the parsing stack;</span><br><span class="line">         advance the input;</span><br><span class="line">    else if the top of the parsing stack is non-terminal A</span><br><span class="line">      and the next input token is terminal a</span><br><span class="line">      and parsing table entry M[A,a] contains production A→X1X2…Xn</span><br><span class="line">    then (* generate *)</span><br><span class="line">         pop the parsing stack;</span><br><span class="line">         for i:&#x3D;n downto 1 do</span><br><span class="line">                push Xi onto the parsing stack;</span><br><span class="line">    else error;</span><br><span class="line">    </span><br><span class="line">if the top of the parsing stack &#x3D; $ </span><br><span class="line">  and the next input token &#x3D; $</span><br><span class="line">then accept</span><br><span class="line">else error.</span><br></pre></td></tr></table></figure><p><br></p><h2 id="First-and-Follow-Sets"><a href="#First-and-Follow-Sets" class="headerlink" title="First and Follow Sets"></a>First and Follow Sets</h2><h3 id="First-sets"><a href="#First-sets" class="headerlink" title="First sets"></a>First sets</h3><blockquote><p>某文法符号展开后可能出现在第一个位置的终结符的集合</p></blockquote><p>令X为一个文法符号（一个终结符或非终结符）或ε，则集合First (X) 由终结符组成，此外可能还有ε。定义如下：</p><ul><li><p>若X是终结符或ε，则First(X) = {X}。</p></li><li><p>若X是非终结符，则对于每个产生式 X→X1 X2 … Xn ，First (X)都包含了First(X1) - {ε}。</p><p>若对于某个 i &lt; n，所有的集合First(X1), … , First(Xi) 都包括了ε，则First(X) 也包括了First(Xi + 1) - {ε}。</p><p>若所有集合First(X1), …, First(Xn)包括了ε，则First(X)也包括ε。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for all non-terminal A do First(A):&#x3D;&#123; &#125;;</span><br><span class="line">while there are changes to any First(A) do</span><br><span class="line">for each production choice A→X1X2…Xndo</span><br><span class="line">k :&#x3D; 1; Continue :&#x3D; true;</span><br><span class="line">while Continue &#x3D; true and k &lt;&#x3D; n do</span><br><span class="line">add First(Xk)-&#123;ε&#125; to First(A);</span><br><span class="line">if ε is not in First(Xk) then Continue:&#x3D; false;</span><br><span class="line">k :&#x3D; k+1;</span><br><span class="line">if Continue &#x3D; true then add ε to First(A);</span><br></pre></td></tr></table></figure><p>Definition:</p><p>  A non-terminal A is <strong>nullable</strong> if there exists a derivation A⇒∗ε</p><p>Theorem:</p><p>  A non-terminal A is <strong>nullable</strong> if and only if First(A) contains ε.</p><h3 id="Follow-sets"><a href="#Follow-sets" class="headerlink" title="Follow sets"></a>Follow sets</h3><blockquote><p>可能出现在某文法符号后一个位置的终结符的集合</p></blockquote><p>给出一个非终结符A，那么集合Follow(A)则是由终结符组成，此外可能还有$。定义如下：</p><ul><li><p>若A是开始符号，则 $ 就在Follow(A)中。</p></li><li><p>若存在产生式B → αAγ，则First(γ) - {ε}在Follow(A)中。</p></li><li><p>若存在产生式B → αAγ，且ε在First(γ)中，则Follow(A)包括Follow(B)。</p></li></ul><p>注意：ε永远不可能是Follow集合的元素，且Follow集合仅针对非终结符进行定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">follow(start-symbol):&#x3D;&#123;$&#125;;</span><br><span class="line">for all non-terminals A≠start-symbol do follow(A):&#x3D;&#123;&#125;;</span><br><span class="line">while there changes to any follow sets do</span><br><span class="line">for each production A→X1X2…Xn do</span><br><span class="line">for each Xi that is a non-terminal do</span><br><span class="line">add First(Xi+1Xi+2…Xn) –&#123;ε&#125; to Follow(Xi)</span><br><span class="line">if ε is in First(Xi+1Xi+2…Xn) then</span><br><span class="line">add Follow(A) to Follow(Xi)</span><br></pre></td></tr></table></figure><h3 id="Constructing-LL-1-parsing-table"><a href="#Constructing-LL-1-parsing-table" class="headerlink" title="Constructing LL(1) parsing table"></a>Constructing LL(1) parsing table</h3><p>为每个非终结符A和产生式 A→α 重复以下两个步骤：</p><ol><li>对于First(α)中的每个记号a，都将A→α添加到项目M[A, a]中。</li><li>若ε在First(α)中，则对于Follow(A) 的每个元素a（记号或是$），都将A→α添加到M[A, a]中。</li></ol><h4 id="LL-1-文法的判定"><a href="#LL-1-文法的判定" class="headerlink" title="LL(1)文法的判定"></a>LL(1)文法的判定</h4><p>A grammar in BNF is LL(1) if the following conditions are satisfied.</p><ol><li>For every production $A→α_1|α_2|…|α_n$,  $First(α_i)∩First(α_j)$ is empty for all i and j, $1≤i,j≤n,i≠j$</li><li>For every non-terminal A such that First(A) contains ε, First(A) ∩ Follow(A) is empty.</li></ol><p><br></p><h2 id="Error-Recovery"><a href="#Error-Recovery" class="headerlink" title="Error  Recovery"></a>Error  Recovery</h2><p>to be continued…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Recursive-Descent&quot;&gt;&lt;a href=&quot;#Recursive-Descent&quot; class=&quot;headerlink&quot; title=&quot;Recursive-Descent&quot;&gt;&lt;/a&gt;Recursive-Descent&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不
      
    
    </summary>
    
      <category term="Notes" scheme="https://iris-cyy.github.io/categories/Notes/"/>
    
      <category term="Compilation Principle" scheme="https://iris-cyy.github.io/categories/Notes/Compilation-Principle/"/>
    
    
      <category term="Notes" scheme="https://iris-cyy.github.io/tags/Notes/"/>
    
      <category term="CP" scheme="https://iris-cyy.github.io/tags/CP/"/>
    
  </entry>
  
  <entry>
    <title>【Algorithm】矩阵快速幂</title>
    <link href="https://iris-cyy.github.io//Notes/Algorithm/2020-03-18/quickpow/"/>
    <id>https://iris-cyy.github.io//Notes/Algorithm/2020-03-18/quickpow/</id>
    <published>2020-03-18T02:21:44.000Z</published>
    <updated>2020-03-18T02:23:38.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整数快速幂"><a href="#整数快速幂" class="headerlink" title="整数快速幂"></a>整数快速幂</h2><p>为了引出矩阵的快速幂，以及说明快速幂算法的好处，我们可以先求整数的幂。</p><p>如果现在要算X^8：则 X*X*X*X*X*X*X*X 按照寻常思路，一个一个往上面乘，则乘法运算进行7次。</p><p>(X*X)*(X*X)*(X*X)*(X*X)</p><p>这种求法，先进行乘法得X^2,然后对X^2再执行三次乘法，这样去计算，则乘法运算执行4次。已经比七次要少。</p><p>所以为了快速算的整数幂，就会考虑这种结合的思想。</p><p>现在要考虑应该怎么分让计算比较快。接下来计算整数快速幂。例如：X^19次方。</p><p>19的二进制为：1 0 0 1 1 。</p><p>由(X^m)*(X^n) = X^(m+n)</p><p>则X^19 = (X^16)*(X^2)*(X^1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickPow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            res *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * x;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multi</span><span class="params">(<span class="keyword">int</span> a[][], <span class="keyword">int</span> b[][], <span class="keyword">int</span> n)</span> <span class="comment">// n*n</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c))</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)&#123;</span><br><span class="line">                c[i][j] += a[i][k] * b[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>把整数乘法中的乘换成矩阵乘即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m[maxn][maxn];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">quickPow</span><span class="params">(Maxtrix a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix res;</span><br><span class="line">    <span class="comment">//res应初始化为单位矩阵，及对角线为1其它为0</span></span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            res = multi(res, a);</span><br><span class="line">        &#125;</span><br><span class="line">        a = multi(a, a);</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;整数快速幂&quot;&gt;&lt;a href=&quot;#整数快速幂&quot; class=&quot;headerlink&quot; title=&quot;整数快速幂&quot;&gt;&lt;/a&gt;整数快速幂&lt;/h2&gt;&lt;p&gt;为了引出矩阵的快速幂，以及说明快速幂算法的好处，我们可以先求整数的幂。&lt;/p&gt;
&lt;p&gt;如果现在要算X^8：则 X*X
      
    
    </summary>
    
      <category term="Notes" scheme="https://iris-cyy.github.io/categories/Notes/"/>
    
      <category term="Algorithm" scheme="https://iris-cyy.github.io/categories/Notes/Algorithm/"/>
    
    
      <category term="Notes" scheme="https://iris-cyy.github.io/tags/Notes/"/>
    
      <category term="Algorithm" scheme="https://iris-cyy.github.io/tags/Algorithm/"/>
    
      <category term="C++" scheme="https://iris-cyy.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【Python】Sequence</title>
    <link href="https://iris-cyy.github.io//Notes/Python/2020-03-17/python_sequence/"/>
    <id>https://iris-cyy.github.io//Notes/Python/2020-03-17/python_sequence/</id>
    <published>2020-03-17T02:37:11.000Z</published>
    <updated>2020-05-31T12:55:15.686Z</updated>
    
    <content type="html"><![CDATA[<p>有序容器（不可变）：字符串(string)、元组(tuple)、列表(list)</p><p>无序容器（可变）：集合、字典</p><h3 id="序列（Sequence）"><a href="#序列（Sequence）" class="headerlink" title="序列（Sequence）"></a>序列（Sequence）</h3><p>不是数据结构，是容器的一种</p><p>下标从0开始</p><p>字符串：’hello’</p><p>列表：[‘h’, ‘e’, ‘l’, ‘l’, ‘o’]</p><p>元组：(‘h’, ‘e’, ‘l’, ‘l’, ‘o’)</p><p>所有序列类型都可以进行如下操作：</p><p><img src="/images/python/python-sequence.assets/image-20200317104445597.png" alt="image-20200317104445597"></p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p><code>&lt;list&gt; [&lt;begin&gt; : &lt;end&gt; : &lt;step&gt;]</code></p><p>如果切片中使用负值访问，表示倒数第几个（如a[1:-3]，表示第1到倒数3（不含）—&gt; 最后一个元素是-1）</p><p>值为0可以省略（如a[:4]）</p><p>end可以大于序列长度（就只切长度内的部分）</p><p>a[::-1] 可用来倒序（或者可以用a.reverse()）</p><p>a[::2] 间隔为2的切片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">12</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::<span class="number">2</span>]</span><br><span class="line">[<span class="number">12</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>::<span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">100</span>:]</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">100</span>] <span class="comment">#error</span></span><br></pre></td></tr></table></figure><p>a[:] 从头到尾切</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>如果将一个序列变量赋值给另外一个变量，则这2个变量表达了同一个序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br></pre></td></tr></table></figure><p>如果希望2个变量各自拥有独立的序列，可使用切片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:] <span class="comment">#表示从头到尾的切片</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br></pre></td></tr></table></figure><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p>+用来连接两个序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">12</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a+b)</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure><p>*用于重复</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]*<span class="number">3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>in判断序列中是否有特定值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">in</span> a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">in</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>]</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">in</span> [[<span class="number">2</span>,<span class="number">3</span>],<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>]</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘e’ <span class="keyword">in</span> ‘hello’</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘he’ <span class="keyword">in</span> ‘hello’</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>len()函数返回序列内部元素的个数</p><p>min()和max()函数计算序列中的最小值和最大值（字符串的大小是按照其Unicode 编码来比较）</p><h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list.index(x, begin, end) <span class="comment">#返回x在list中的下标</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set(input()) <span class="comment">#去重（放进集合）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.sort() <span class="comment">#排序，有key(排序依据), reverse(True表示降序，默认升序)等参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">''</span>.join(s)) <span class="comment">#s如果是['1','2','3','a']这样，将会去掉''并合并，输出123a</span></span><br></pre></td></tr></table></figure><p>注意，find只能用于str，不能用于list</p><p>Random.shuffle() 打乱原列表中元素的顺序</p><p>sort() 用来直接排序，不返回（a.sort()即可）</p><p>replace 返回替代完后的值，不改变原列表（s = s.replace(‘a’, ‘b’)）</p><p>remove 删除第一个值是这样的元素（在原列表中改）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'1'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.remove(<span class="string">'1'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a </span><br><span class="line">[<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'1'</span>]</span><br></pre></td></tr></table></figure><p>pop() 返回list的最后一个元素，并将其在list里面去掉</p><p>random.randint(x, y) 生成x,y区间内的随机数（包含x和y）</p><p><br></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>单引号和双引号没有区别</p><p>当在双引号” “内部还需要使用引号时，可以使用单引号 ’ ’，当在单引号’ ’ 内部需要使用引号时，可以使用双引号” “</p><p>用<code>s[i]</code>访问字符串s中的第i个字符，i=-1时访问最后一个字符</p><p>子串：s[m:n]，访问第m到第n-1组成的子串 </p><p>不以<code>\0</code>作为字符串结尾</p><p><code>\</code>用作转义，<code>\v</code>纵向制表符，<code>\r</code>回车，<code>\f</code>换页</p><p>用三引号时可以在字符串内部换行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"""hello </span></span><br><span class="line"><span class="string">world</span></span><br><span class="line"><span class="string">haha"""</span>)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># hello</span></span><br><span class="line"><span class="comment"># world</span></span><br><span class="line"><span class="comment"># haha</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"hello"</span></span><br><span class="line">      <span class="string">"haha"</span>)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># hellohaha</span></span><br></pre></td></tr></table></figure><p>或者可以用<code>\</code>在字符串内部换行，但与三引号不同的是，输出不随之换行，只能用来处理长字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"hello\</span></span><br><span class="line"><span class="string">world\</span></span><br><span class="line"><span class="string">haha"</span>)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># helloworldhaha</span></span><br></pre></td></tr></table></figure><p><code>+</code>连接两个字符串（必须两个都是str，不能是其他如int等）</p><p><code>*</code>用复制一个字符串若干次形成新的字符串（*后面的必须是整数）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ab'</span>*<span class="number">2</span></span><br><span class="line"><span class="string">'abab'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'a'</span>*<span class="number">5</span></span><br><span class="line"><span class="string">'aaaaa'</span></span><br></pre></td></tr></table></figure><p>比大小，从前往后按位比，’a’&lt;’b’，’A’&lt;’a’</p><p>在一个字符串字面量前加一个字符r，表示这个字符串是原始字符串，其中的\不被当作是转义字符前缀。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">r'hello\nworld'</span> <span class="comment">#相当于s='hello\\nworld'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(s)</span><br><span class="line">hello\nworld</span><br></pre></td></tr></table></figure><p>字符串不可修改（元素赋值，切片赋值都是非法的），字符串中的数据（字符）是不能修改的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>] = <span class="string">'k'</span> <span class="comment">#error</span></span><br></pre></td></tr></table></figure><p>可以通过用新的字符串对变量重新赋值，表示新的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'bye'</span></span><br></pre></td></tr></table></figure><p>一些函数：</p><p><img src="/images/python/python-basis.assets/image-20200317111848986.png" alt="image-20200317111848986"></p><p><code>s.replace(old, new)</code>：把字符串s中的所有子串old都替换成new</p><p><code>find()</code>: 在字符串中查找子串，返回第一次出现的位置下标（从0开始），如果找不到返回-1</p><p>可以指定查找范围</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'This is a test.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.find(<span class="string">'is'</span>))   </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'This is a test.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.find(<span class="string">'ok'</span>))   </span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'This is a test. '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.find(<span class="string">'is'</span>,<span class="number">3</span>)) <span class="comment">#指定查找开始位置</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'This is a test.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.find(<span class="string">'is'</span>,<span class="number">3</span>,<span class="number">6</span>)) <span class="comment">#指定查找开始位置及终止位置</span></span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure><p>替换多个单字符：translate()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = str.maketrans (<span class="string">'abc'</span>,<span class="string">'zyx'</span>) <span class="comment">#不要求是连续子串，会把a全部换成z，b全部换成y..</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"abcdefgabc"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.translate(table)</span><br><span class="line"><span class="string">'zyxdefgzyx'</span></span><br></pre></td></tr></table></figure><blockquote><p>加密：A -&gt; C, B -&gt; D, …</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">pt = string.ascii_uppercase <span class="comment">#pt = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></span><br><span class="line">ct = pt[<span class="number">2</span>:] + pt[:<span class="number">2</span>] <span class="comment">#ct = 'CDEFGHIJKLMNOPQRSTUVWXYZ' + 'AB'</span></span><br><span class="line">table = str.maketrans(pt, ct) <span class="comment">#一一对应关系，生成转换表</span></span><br><span class="line">ins = input()</span><br><span class="line">ours = ins.translate(table) <span class="comment">#根据table进行转换</span></span><br><span class="line">print(outs)</span><br></pre></td></tr></table></figure></blockquote><p><img src="/images/python/python-basis.assets/image-20200317112450368.png" alt="image-20200317112450368"></p><p><br></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[&lt;expression&gt; <span class="keyword">for</span> &lt;item&gt; <span class="keyword">in</span> &lt;iterable&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2</span>*n <span class="keyword">for</span> n <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum([<span class="number">1</span>/i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">21</span>)]) <span class="comment">#求1+1/2+...+1/20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum([ <span class="number">1</span>/i <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span>/i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>)]) <span class="comment">#求1-1/2+1/3-1/4+...前n项和</span></span><br><span class="line"></span><br><span class="line">[&lt;expression&gt; <span class="keyword">for</span> &lt;item&gt; <span class="keyword">in</span> &lt;iterable&gt; <span class="keyword">if</span> &lt;condition&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2</span>*n <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">8</span>) <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">1</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">14</span>]</span><br></pre></td></tr></table></figure><p>列表中元素可以是不同类型，且元素可以被修改</p><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>单元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># [2,3,5,7,9]</span></span><br></pre></td></tr></table></figure><p>切片赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = list(<span class="string">'Perl'</span>)</span><br><span class="line">name[<span class="number">2</span>:] = list(<span class="string">'ar'</span>)</span><br><span class="line">print(name)</span><br><span class="line"><span class="comment"># ['P','e','a','r']</span></span><br></pre></td></tr></table></figure><h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">b = a <span class="comment">#深拷贝</span></span><br><span class="line">c = a[:] <span class="comment">#浅拷贝</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="number">2</span> <span class="comment">#不会改变a，a:[1,2,3,4] c:[2,2,3,4]</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span> <span class="comment">#同时改变a，a:[2,2,3,4] b:[2,2,3,4]</span></span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>del name[2]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = list(<span class="string">'Perl'</span>)</span><br><span class="line"><span class="keyword">del</span> name[<span class="number">2</span>]</span><br><span class="line">print(name)</span><br><span class="line"><span class="comment"># ['P', 'e', 'l']</span></span><br></pre></td></tr></table></figure><p><img src="/images/python/python-basis.assets/QQ20200412-0.png" alt="QQ20200412-0"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">a.append(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># a: [2,3,4,5]</span></span><br><span class="line">a.extend([<span class="number">6</span>,<span class="number">7</span>])</span><br><span class="line"><span class="comment"># a: [2,3,4,5,6,7]</span></span><br><span class="line">a.insert(<span class="number">2</span>,<span class="number">8</span>)</span><br><span class="line"><span class="comment"># a: [2,3,8,4,5,6,7]</span></span><br><span class="line">a.insert(<span class="number">10</span>, <span class="number">9</span>)</span><br><span class="line"><span class="comment"># a: [2,3,8,4,5,6,7,9] 位置10不存在，所以加到最后</span></span><br><span class="line">print(a.index(<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 1 有多个时输出第一个的下标（如果不存在会error）</span></span><br><span class="line">a.remove(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># a: [2,3,8,4,6,7,9] 有多个时删除第一个（如果不存在会error）</span></span><br><span class="line">a.pop()</span><br><span class="line"><span class="comment"># a: [2,3,8,4,6,7]</span></span><br><span class="line">a.pop(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># a: [2,3,4,6,7]</span></span><br><span class="line">a.reverse()</span><br><span class="line"><span class="comment"># a: [7,6,4,3,2]</span></span><br><span class="line">a.sort() <span class="comment">#默认升序，可添加参数reverse，reverse=True降序，reverse=False升序</span></span><br><span class="line"><span class="comment"># a: [2,3,4,6,7]</span></span><br></pre></td></tr></table></figure><h4 id="二维列表"><a href="#二维列表" class="headerlink" title="二维列表"></a>二维列表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">m = [[<span class="number">0</span>] * <span class="number">3</span>] * <span class="number">4</span> <span class="comment">#改变m[0][0]时会同时改变m[0][0],m[1][0],m[2][0],m[3][0]</span></span><br><span class="line">m = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br></pre></td></tr></table></figure><p><img src="/images/python/python-sequence.assets/image-20200421100947198.png" alt="image-20200421100947198"></p><p><img src="/images/python/python-sequence.assets/image-20200421100911011.png" alt="image-20200421100911011"></p><p><br></p><h3 id="字符串和列表的互相操作"><a href="#字符串和列表的互相操作" class="headerlink" title="字符串和列表的互相操作"></a>字符串和列表的互相操作</h3><p>split()：拆分字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date = <span class="string">'3/11/2018'</span></span><br><span class="line">a = date.split(<span class="string">'/'</span>) <span class="comment">#如果不加参数则默认是以空格拆分</span></span><br><span class="line"><span class="comment"># a: ['3','11','2018']</span></span><br></pre></td></tr></table></figure><p>join()：将列表中各类型元素组合成一个字符串，元素之间用指定内容填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'hello'</span>，<span class="string">'good'</span>,<span class="string">'boy'</span>]</span><br><span class="line">print(<span class="string">' '</span>.join(a))</span><br><span class="line"><span class="comment"># hello good boy</span></span><br><span class="line">print(<span class="string">':'</span>.join(a))</span><br><span class="line"><span class="comment"># hello:good:boy</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>可以是任意类型</p><p>字面量用()而不是[]</p><p>tuple()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = tuple([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># (2,3,4,5)</span></span><br></pre></td></tr></table></figure><p>不可修改！！！！（增加、删除、修改、排序都不可）</p><p>T.count(x) 计算x元素出现的次数</p><p>T.index(x) 计算x元素第一次出现的下标</p><p>速度比列表快</p><p>可以作为字典的key或者集合的元素（列表不可）</p><p><br></p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>set()</p><p>无序、不重复</p><p>可以用{}或者set()来创建（但是空集合必须用set()创建）</p><p>集合元素之能是不可变类型</p><p>集合的底层是哈希表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'c'</span>&#125;</span><br><span class="line"><span class="comment"># a: &#123;'a','b','c'&#125; 去重</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'a'</span> <span class="keyword">in</span> a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'d'</span> <span class="keyword">in</span> a</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="集合间运算"><a href="#集合间运算" class="headerlink" title="集合间运算"></a>集合间运算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = set(<span class="string">'alacazam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a                                  </span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a - b                              <span class="comment"># 集合a中包含而集合b中不包含的元素</span></span><br><span class="line">&#123;<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a | b                              <span class="comment"># 集合a或b中包含的所有元素</span></span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'m'</span>, <span class="string">'z'</span>, <span class="string">'l'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a &amp; b                              <span class="comment"># 集合a和b中都包含了的元素</span></span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'c'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a ^ b                              <span class="comment"># 不同时包含于a和b的元素</span></span><br><span class="line">&#123;<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'m'</span>, <span class="string">'z'</span>, <span class="string">'l'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">9</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 == s2</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>s1.issubset(s2)判断s1是否是s2的子集</p><p>s2.issuperset(s1)判断是s1是否是s2的超集（子集的反义词是超集）</p><p>s1 &lt; s2: s1是s2的真子集</p><p>s1 &lt;= s2: s1是s2的子集</p><p>s1 &gt; s2: s1是s2的真超集</p><p>s1 &gt;= s2: s1是s2的超集</p><p><img src="/images/python/python-sequence.assets/image-20200421215416263.png" alt="image-20200421215416263"></p><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>添加元素：s.add(x)、s.update(x)</p><p>移除元素：s.remove(x)（如果元素不存在会error）、s.discard(x)（如果元素不存在不会error）</p><p>随机删除集合中的一个元素：s.pop()</p><p>清空：s.clear()</p><p>max()获取最大值，min()获取最小值，sum()求和，len()获取集合元素数量</p><p><img src="/images/python/python-sequence.assets/image-20200412213157677.png" alt="image-20200412213157677"></p><p><br></p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>dict() 或者用空的{}创建空的字典</p><p>key-value</p><p>其中key必须是不可变类型（所以list不可以作为key）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores = &#123;<span class="string">'语文'</span>: <span class="number">89</span>, <span class="string">'数学'</span>: <span class="number">92</span>, <span class="string">'英语'</span>: <span class="number">93</span>&#125;</span><br></pre></td></tr></table></figure><p>通过key可以访问到value</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>scores[<span class="string">'语文'</span>]</span><br><span class="line"><span class="number">89</span></span><br></pre></td></tr></table></figure><p>为不存在的key赋值即会为dict添加键值对</p><p>in 和 not in 都是基于key来判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'a'</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>d.clear() 清空</p><p>d.get(‘key’) 通过key获得value</p><p>d.update({‘key’ : value}) 更新键值对，可以同时更新多组（如果存在key则更改value，不存在则新建）</p><p>items()、keys()、values() 分别用于获取字典中的所有 key-value 对、所有 key、所有 value</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cars = &#123;<span class="string">'BMW'</span>: <span class="number">8.5</span>, <span class="string">'BENS'</span>: <span class="number">8.3</span>, <span class="string">'AUDI'</span>: <span class="number">7.9</span>&#125;</span><br><span class="line"><span class="comment"># 获取字典所有的key-value对，返回一个dict_items对象</span></span><br><span class="line">ims = cars.items()</span><br><span class="line">print(type(ims)) <span class="comment"># &lt;class 'dict_items'&gt;</span></span><br><span class="line"><span class="comment"># 将dict_items转换成列表</span></span><br><span class="line">print(list(ims)) <span class="comment"># [('BMW', 8.5), ('BENS', 8.3), ('AUDI', 7.9)]</span></span><br><span class="line"><span class="comment"># 访问第2个key-value对</span></span><br><span class="line">print(list(ims)[<span class="number">1</span>]) <span class="comment"># ('BENS', 8.3)</span></span><br><span class="line"><span class="comment"># 获取字典所有的key，返回一个dict_keys对象</span></span><br><span class="line">kys = cars.keys()</span><br><span class="line">print(type(kys)) <span class="comment"># &lt;class 'dict_keys'&gt;</span></span><br><span class="line"><span class="comment"># 将dict_keys转换成列表</span></span><br><span class="line">print(list(kys)) <span class="comment"># ['BMW', 'BENS', 'AUDI']</span></span><br><span class="line"><span class="comment"># 访问第2个key</span></span><br><span class="line">print(list(kys)[<span class="number">1</span>]) <span class="comment"># 'BENS'</span></span><br><span class="line"><span class="comment"># 获取字典所有的value，返回一个dict_values对象</span></span><br><span class="line">vals = cars.values()</span><br><span class="line"><span class="comment"># 将dict_values转换成列表</span></span><br><span class="line">print(type(vals)) <span class="comment"># [8.5, 8.3, 7.9]</span></span><br><span class="line"><span class="comment"># 访问第2个value</span></span><br><span class="line">print(list(vals)[<span class="number">1</span>]) <span class="comment"># 8.3</span></span><br></pre></td></tr></table></figure><p>pop() 方法用于获取指定 key 对应的 value，并删除这个 key-value 对</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cars = &#123;<span class="string">'BMW'</span>: <span class="number">8.5</span>, <span class="string">'BENS'</span>: <span class="number">8.3</span>, <span class="string">'AUDI'</span>: <span class="number">7.9</span>&#125;</span><br><span class="line">print(cars.pop(<span class="string">'AUDI'</span>)) <span class="comment"># 7.9</span></span><br><span class="line">print(cars) <span class="comment"># &#123;'BMW': 8.5, 'BENS': 8.3&#125;</span></span><br></pre></td></tr></table></figure><p>popitem() 方法用于随机弹出字典中的一个 key-value 对（事实上是弹出最后一个，但是字典中的顺序不可知）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cars = &#123;<span class="string">'AUDI'</span>: <span class="number">7.9</span>, <span class="string">'BENS'</span>: <span class="number">8.3</span>, <span class="string">'BMW'</span>: <span class="number">8.5</span>&#125;</span><br><span class="line">print(cars)</span><br><span class="line"><span class="comment"># 弹出字典底层存储的最后一个key-value对</span></span><br><span class="line">print(cars.popitem()) <span class="comment"># ('AUDI', 7.9)</span></span><br><span class="line">print(cars) <span class="comment"># &#123;'BMW': 8.5, 'BENS': 8.3&#125;</span></span><br><span class="line"><span class="comment"># 注意：弹出的是键值对，所以要用两个变量来分别接受</span></span><br></pre></td></tr></table></figure><p>del可用于删除项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> score[<span class="string">'语文'</span>]</span><br></pre></td></tr></table></figure><p>len可以获取字典条目的数量</p><p>==和!=比较两个字典是否相同（键和值都相同，和项的顺序无关）</p><p><img src="/images/python/python-sequence.assets/image-20200421214546338.png" alt="image-20200421214546338"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有序容器（不可变）：字符串(string)、元组(tuple)、列表(list)&lt;/p&gt;
&lt;p&gt;无序容器（可变）：集合、字典&lt;/p&gt;
&lt;h3 id=&quot;序列（Sequence）&quot;&gt;&lt;a href=&quot;#序列（Sequence）&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="Notes" scheme="https://iris-cyy.github.io/categories/Notes/"/>
    
      <category term="Python" scheme="https://iris-cyy.github.io/categories/Notes/Python/"/>
    
    
      <category term="Notes" scheme="https://iris-cyy.github.io/tags/Notes/"/>
    
      <category term="Python" scheme="https://iris-cyy.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【Compilation Principle】Context-Free Grammars and Parsing</title>
    <link href="https://iris-cyy.github.io//Notes/Compilation-Principle/2020-03-10/cp_parsing/"/>
    <id>https://iris-cyy.github.io//Notes/Compilation-Principle/2020-03-10/cp_parsing/</id>
    <published>2020-03-10T06:35:55.000Z</published>
    <updated>2020-03-13T10:22:08.280Z</updated>
    
    <content type="html"><![CDATA[<p>语法分析树的结构取决于语言的结构，且是一种动态的数据结构（可以增、删、改）</p><h2 id="Context-Free-Grammar-CFG"><a href="#Context-Free-Grammar-CFG" class="headerlink" title="Context-Free Grammar (CFG)"></a>Context-Free Grammar (CFG)</h2><p>$RE ⊆ CFG$</p><p>产生式左边（LHS，left-hand sides）只有一个符号，且是非终结符</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>A Context-Free Grammar is a 4-tuple $(V,Σ,S,→)$, where</p><ul><li>$V$ is a finite set of nonterminal symbols</li><li>$Σ$ is a finite set of terminal symbols</li><li>$S ∈ V $ is a distinguished nonterminal, the start symbol</li><li>$→ ⊆  V × (V ∪ Σ)^*  Σ)^*​$ is a finite relation, the productions</li></ul><p>更加正式的定义：</p><p>$G = (T,N,P,S)$</p><ul><li>$T$: Terminals</li><li>$N$: Nonterminals (disjoint from T)</li><li>$P$: Productions (Grammar rules), $A \rightarrow a,\;A \in N, \; a \in (T \cup N)^*$</li><li>$S$: Start symbol ($S \in N$)</li><li>sentencial from: a string in  $(T \cup N)^*$</li><li>sentence: $T^*​$，只能由终结符组成</li><li>$T \cup N$ 表示文法的所有符号</li><li>$\alpha \Rightarrow^* \beta$ 表示​$\alpha$可以通过 ​$n \; (n\geq 0)$ 步变换为​$\beta$</li><li>derivation: ${S \Rightarrow^* w} {\; (w \in T^*)}$</li><li>$L(G)​$: 由文法生成的语言，$L(G) = {w \in T^*\;|\;there \; exists \; a derivation\; S \Rightarrow^* w \; of \; G}​$</li><li>rightmost derivation: $S \Rightarrow_{rm}^* w ​$, $a A \gamma \Rightarrow a \beta \gamma, \, a \in T^*​$</li><li>leftmost derivation: $S \Rightarrow_{lm}^* w ​$, $a A \gamma \Rightarrow a \beta \gamma, \, \gamma \in T^*​$</li></ul><h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><p>BNF范式</p><p>通常用大写字母表示非终结符，用小写表示终结符</p><h4 id="递归（recursion）"><a href="#递归（recursion）" class="headerlink" title="递归（recursion）"></a>递归（recursion）</h4><ul><li>左递归：LHS的非终结符出现在RHS的第一个字符$A \rightarrow A \, \alpha \, | \, \beta$ 等价于 $(\beta\alpha^*)$</li><li>右递归：LHS的非终结符出现在RHS的最后一个字符$A \rightarrow \alpha \, A \, | \, \beta$  等价于 $(\alpha^*\beta)$</li></ul><p>$\alpha$、$\beta$是任意的串（终结符或非终结符都可），其中$\beta$不以$A$为开头/结尾</p><p>两者在很多情况下不等价</p><h4 id="epsilon-产生式（-epsilon-production-）"><a href="#epsilon-产生式（-epsilon-production-）" class="headerlink" title="$\epsilon$ 产生式（$\epsilon-production$）"></a>$\epsilon$ 产生式（$\epsilon-production$）</h4><p>$empty \, \rightarrow \, \epsilon$</p><p>用于产生空串，如果语言中要有空串，必须要有$\epsilon$ 产生式</p><p>如$a^*$相当于$A \rightarrow A \, \alpha \, | \, \epsilon \; or \; A \rightarrow \alpha \, A \, | \, \epsilon$</p><p>$\epsilon$ 作用：让文法更简洁，效率更高</p><p>eg.  $A \rightarrow (A) \, A \,| \, \epsilon$，生成能够匹配的括号</p><p>正规表达式没有记忆功能，上下文无关语法可以</p><h2 id="Parse-Trees-and-Abstract-Syntax-Trees"><a href="#Parse-Trees-and-Abstract-Syntax-Trees" class="headerlink" title="Parse Trees and  Abstract Syntax Trees"></a>Parse Trees and  Abstract Syntax Trees</h2><h3 id="Parse-Trees"><a href="#Parse-Trees" class="headerlink" title="Parse Trees"></a>Parse Trees</h3><p>用树的形态来表示推导，推导和树是多对一的关系</p><p>非叶节点表示非终结符，叶节点表示终结符</p><p>最左推导（leftmost derivation）：每次展开最左边的非终结符，对应parse tree的前序遍历</p><p>最右推导（rightmost derivation）：每次展开最右边的非终结符，对应parse tree的后序遍历</p><p>每一棵树都只有唯一的最左推导和最右推导</p><p>eg.</p><p><img src="/images/comp/com-prin3.assets/image-20200313125644213.png" alt="image-20200313125644213" style="zoom:77%;" /></p><p>要注意的是在文法分析中关注的是类型而不是语义（因此parse tree的叶节点推出的是number而不是具体的3or4），词义在语义分析中进行处理</p><h3 id="Abstract-Syntax-Trees"><a href="#Abstract-Syntax-Trees" class="headerlink" title="Abstract Syntax Trees"></a>Abstract Syntax Trees</h3><p>parse tree 的压缩版（更简洁）</p><p>用运算符/操作作为根节点和内部节点，操作数作为子节点</p><p>在树中不体现推导过程，只显示推导结果</p><p><img src="/images/comp/com-prin3.assets/image-20200313130211688.png" alt="image-20200313130211688" style="zoom:67%;" /></p><p>（+其实代表相加的结果）</p><blockquote><p>eg.  </p><p><img src="/images/comp/com-prin3.assets/image-20200313135958685.png" alt="image-20200313135958685" style="zoom:60%;" /></p><p>parse tree:</p><p><img src="/images/comp/com-prin3.assets/image-20200313132604830.png" alt="image-20200313132604830" style="zoom:60%;" /></p><p>syntax tree:</p><p><img src="/images/comp/com-prin3.assets/image-20200313132630115.png" alt="image-20200313132630115" style="zoom:60%;" /></p></blockquote><p>孩子个数可能不定，可以用leftmost-child right sibling来表达</p><p><img src="/images/comp/com-prin3.assets/image-20200313134540122.png" alt="image-20200313134540122" style="zoom:67%;" /></p><p><br></p><h2 id="歧义（ambiguity）"><a href="#歧义（ambiguity）" class="headerlink" title="歧义（ambiguity）"></a>歧义（ambiguity）</h2><p>一个可以构建两个不同结构的parse tree的语法具有歧义（可能会因为没有区分优先级和结合律造成）</p><p>符号离树根越远优先级越高</p><p>解决方法：</p><ol><li><p>定义一个消除歧义的规则，例如指明哪一种tree是对的</p><p>优点：不需要改变原来的语法</p><p>缺点：文法结构并非只由语法来规定（grammar+rule）</p></li><li><p>改造文法，使得没有语法错误</p><p>缺点：改造文法可能会降低可读性（有时候为了简洁性，可能还是会选择保留原来有歧义的形态）</p></li></ol><p>结合律：</p><ul><li>A left recursive rule makes its operators associate on the left.</li><li>A right recursive rule makes them associate on the right.</li></ul><p><img src="/images/comp/com-prin3.assets/image-20200313173754736.png" alt="image-20200313173754736" style="zoom: 65%;" /></p><blockquote><p>eg1.</p><p><img src="/images/comp/com-prin3.assets/image-20200313135853556.png" alt="image-20200313135853556" style="zoom:60%;" /></p><p>会有歧义，因为没有规定*和+-的优先级，如34-3*42</p><p>改成规定*优先级更高之后可以消除歧义（但parse tree会变得更加复杂）：</p><p><img src="/images/comp/com-prin3.assets/image-20200313135907660.png" alt="image-20200313135907660" style="zoom:60%;" /></p></blockquote><h3 id="Dangling-else-problem"><a href="#Dangling-else-problem" class="headerlink" title="Dangling else problem"></a>Dangling else problem</h3><p>if语句的else匹配可能会带来歧义</p><p>C中引入了{}来消除歧义，在Ada中引入end if</p><p>在文法中，可以用类似以下的方法：</p><p><img src="/images/comp/com-prin3.assets/image-20200313140454490.png" alt="image-20200313140454490" style="zoom:67%;" /></p><p>Ada的文法（用BNF表示）</p><p><img src="/images/comp/com-prin3.assets/image-20200313140810313.png" alt="image-20200313140810313" style="zoom:60%;" /></p><h3 id="Inessential-ambiguity"><a href="#Inessential-ambiguity" class="headerlink" title="Inessential ambiguity"></a>Inessential ambiguity</h3><p>有一些歧义无关紧要，具体得看语义</p><p><br></p><h2 id="EBNF（Extended-BNF）"><a href="#EBNF（Extended-BNF）" class="headerlink" title="EBNF（Extended BNF）"></a>EBNF（Extended BNF）</h2><p>在BNF基础上增加重复（{…}）和选择（[]，一次或零次）</p><p><img src="/images/comp/com-prin3.assets/image-20200313142632731.png" alt="image-20200313142632731" style="zoom:60%;" /></p><p><img src="/images/comp/com-prin3.assets/image-20200313142721793.png" alt="image-20200313142721793" style="zoom:60%;" /></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;语法分析树的结构取决于语言的结构，且是一种动态的数据结构（可以增、删、改）&lt;/p&gt;
&lt;h2 id=&quot;Context-Free-Grammar-CFG&quot;&gt;&lt;a href=&quot;#Context-Free-Grammar-CFG&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Notes" scheme="https://iris-cyy.github.io/categories/Notes/"/>
    
      <category term="Compilation Principle" scheme="https://iris-cyy.github.io/categories/Notes/Compilation-Principle/"/>
    
    
      <category term="Notes" scheme="https://iris-cyy.github.io/tags/Notes/"/>
    
      <category term="CP" scheme="https://iris-cyy.github.io/tags/CP/"/>
    
  </entry>
  
  <entry>
    <title>【Compilation Principle】Scanning (Lexical Analysis)</title>
    <link href="https://iris-cyy.github.io//Notes/Compilation-Principle/2020-03-04/cp_scanning/"/>
    <id>https://iris-cyy.github.io//Notes/Compilation-Principle/2020-03-04/cp_scanning/</id>
    <published>2020-03-04T09:21:17.000Z</published>
    <updated>2020-03-16T07:32:13.188Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/comp/com-prin2.assets/image-20200308123221931.png" alt="image-20200308123221931" style="zoom:50%;" /></p><h2 id="Scanning-Process"><a href="#Scanning-Process" class="headerlink" title="Scanning Process"></a>Scanning Process</h2><ul><li>Identifier: x y11 elsen_i00</li><li>Integer: 2 1000 -500 5L</li><li>Floating point: 2.0 0.00020 .02 1. 1e5 0.e-10</li><li>String: “x” “He said, \“Are you?\””</li><li>Comment: /<strong> don’t change this </strong>/</li><li>Keyword: if else while break</li><li>Symbol: + * { } ++ &lt; &lt;&lt; [ ] &gt;=</li></ul><p><br></p><h2 id="正则表达式（Regular-Expression-RE）"><a href="#正则表达式（Regular-Expression-RE）" class="headerlink" title="正则表达式（Regular Expression, RE）"></a>正则表达式（Regular Expression, RE）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>通过递归定义</p><p><img src="/images/comp/com-prin2.assets/image-20200308123456675.png" alt="image-20200308123456675" style="zoom: 50%;" /></p><p>其中运算的优先级：alternation &lt; concatenation &lt; repetition(R*)</p><p>RE的表达形式不唯一</p><p>RE不可计数（不可记忆）</p><p>eg. </p><p><img src="/images/comp/com-prin2.assets/image-20200308123721443.png" alt="image-20200308123721443" style="zoom:50%;" /></p><p>Regular Set: RE 的集合（正规表达式封闭）</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><p><code>R+</code> : one or more strings from L(R): <code>R(R*)</code></p></li><li><p><code>R?</code>: optional R（一次或零次）: <code>(R|ε)</code> </p></li><li><p><code>[abce]</code>: one of the listed characters: <code>(a|b|c|e)</code></p></li><li><p><code>[a-z]</code>: one character from this range: <code>(a|b|c|d|e|…|y|z)</code> </p><p>eg. [A-Z a-z]表示包含大小写的所有字母</p></li><li><p><code>[^ab]</code>: anything but one of the listed chars</p></li><li><p><code>[^a-z]</code>: one character not from this range</p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul><li><p><strong>Numbers</strong><br>自然数：<em>nat</em> = [0-9]+<br>有符号自然数：<em>signedNat</em> = (+|-)?<em>nat</em><br>实数（可能包含小数点or科学计数法）：<em>number</em> = <em>signedNat</em>(“．”” <em>nat</em>)? (E <em>signedNat</em>)?</p></li><li><p><strong>Reserved Words and Identifiers</strong><br>保留字（一般枚举表示）：<em>reserved</em> = if | while | do |………<br>字母：<em>letter</em> = [a-z A-Z]<br>数字：<em>digit</em> = [0-9]<br>标识符：<em>identifier</em> = <em>letter</em> (<em>letter</em> | <em>digit</em>)*</p><blockquote><p>$reserved \subset iderntifier$</p></blockquote></li><li><p><strong>Comment</strong></p><p><img src="/images/comp/com-prin2.assets/image-20200308125010856.png" alt="image-20200308125010856" style="zoom:55%;" /></p></li></ul><h3 id="一些原则"><a href="#一些原则" class="headerlink" title="一些原则"></a>一些原则</h3><h4 id="处理歧义"><a href="#处理歧义" class="headerlink" title="处理歧义"></a>处理歧义</h4><ul><li><p>keyword优先</p><p>如果一个标识符可以是keyword，就优先认为它是keyword（如if）</p></li><li><p>最长子串匹配</p><p>如果能被当成是一个identifier，就不会当成多个（例如iff，可以是iff或者if+f，认为是iff）</p><p>明确认为属于其他标记作为分隔符</p></li></ul><h4 id="空白符"><a href="#空白符" class="headerlink" title="空白符"></a>空白符</h4><p>用于分割，没有返回</p><p><em>whitespace</em> = ( <em>newline</em> | <em>blank</em> | <em>tab</em> | <em>comment</em> )+</p><h4 id="Lookahead"><a href="#Lookahead" class="headerlink" title="Lookahead"></a>Lookahead</h4><p>缓冲区内可能存在下一个输入的符号，要标记回溯位置</p><p><br></p><h2 id="有限自动机（Finite-Automata-FA）"><a href="#有限自动机（Finite-Automata-FA）" class="headerlink" title="有限自动机（Finite Automata, FA）"></a>有限自动机（Finite Automata, FA）</h2><p>状态个数有限</p><p>state 可以重复</p><ul><li><p><strong>transition</strong>：标记两个状态之间的转换</p></li><li><p><strong>start state</strong>：开始状态前要加无标签箭头</p></li><li><strong>accepting state</strong>：用双环表示接收（结束）状态（单环表示非接收状态），转换可以到接收态结束</li></ul><p>有的状态不接受一些字符，即接收了会进入error state，可以不在图中表示出来</p><h3 id="确定型有限自动机（Deterministic-Finite-Automation-DFA）"><a href="#确定型有限自动机（Deterministic-Finite-Automation-DFA）" class="headerlink" title="确定型有限自动机（Deterministic Finite Automation, DFA）"></a>确定型有限自动机（Deterministic Finite Automation, DFA）</h3><p>状态转移目标确定（唯一）</p><p>状态转移时接收<u>一个</u>符号（可以用名字表示）</p><p>$T:S \times \sum \rightarrow S$，$T(s,c)$ 必须对<u>每一个</u>s和c都有值（error state可以不画在图中）</p><p><strong>Typical action</strong></p><ol><li>making an transition：从输入缓冲区得到字符，得到字符串（字符串值或者词义）</li><li>reaching an accepting state：将token和相关属性（字符串内容、数字值等）返回给词法分析器</li><li>reaching an error state：回退（之前分析的可能不对）或者生成error token</li></ol><p>eg.</p><p><img src="/images/comp/com-prin2.assets/image-20200308184915152.png" alt="image-20200308184915152" style="zoom:60%;" /></p><h3 id="非确定型有限自动机（Nondeterministic-Finite-Automaton-NFA）"><a href="#非确定型有限自动机（Nondeterministic-Finite-Automaton-NFA）" class="headerlink" title="非确定型有限自动机（Nondeterministic Finite Automaton, NFA）"></a>非确定型有限自动机（Nondeterministic Finite Automaton, NFA）</h3><p>NFA与DFA功能等价，可以相互转换</p><p>主要区别在于，NFA有 $\epsilon - transition$（不消耗输入的转移）</p><p>$\epsilon - transition$ 的两个主要作用：</p><ol><li>选择功能（不用合并新来的状态，而是增加一个新的状态）</li><li>匹配外部输入的空串</li></ol><p>NFA的定义包括转换关系（不一定是函数）T、开始状态s0、接收状态A、接受语言L(M)</p><p>表达比较灵活，可以有变数（与之对应的是，可能会影响分析效率）</p><p><br></p><h2 id="【IMPORTANT】从RE到DFA的转换"><a href="#【IMPORTANT】从RE到DFA的转换" class="headerlink" title="【IMPORTANT】从RE到DFA的转换"></a>【IMPORTANT】从RE到DFA的转换</h2><p><img src="/images/comp/com-prin2.assets/image-20200308205252875.png" alt="image-20200308205252875" style="zoom: 50%;" /></p><h3 id="RE-gt-NFA"><a href="#RE-gt-NFA" class="headerlink" title="RE -&gt; NFA"></a>RE -&gt; NFA</h3><h4 id="Top-down"><a href="#Top-down" class="headerlink" title="Top-down"></a>Top-down</h4><p><img src="/images/comp/com-prin2.assets/20160927164801462" alt="img" style="zoom: 80%;" /></p><h4 id="Thompson’s-construction-Bottom-up"><a href="#Thompson’s-construction-Bottom-up" class="headerlink" title="Thompson’s construction (Bottom-up)"></a>Thompson’s construction (Bottom-up)</h4><p>对于单个字符，构造一个如下图所示的转换图，作为一个单元：</p><p><img src="/images/comp/com-prin2.assets/20160927182858046" alt="a" style="zoom:90%;" /></p><p>在遇到操作符时，所有的处理都针对单元（在下图上用虚线圈表示）：</p><p><img src="/images/comp/com-prin2.assets/20160927185627441" alt="op" style="zoom:90%;" /></p><p>在处理完操作符之后，形成新的单元，然后继续下一次处理（类似递归），直到转换为NFA</p><h3 id="NFA-gt-DFA"><a href="#NFA-gt-DFA" class="headerlink" title="NFA -&gt; DFA"></a>NFA -&gt; DFA</h3><ol><li>先得到每个状态对应的$\epsilon$闭包（当前状态下能够通过$\epsilon$推出的所有状态的集合，先找出该状态的ε边推出的所有状态，再找那些状态的ε边推出的状态，是一个迭代的过程，直到找出一个状态的ε闭包）</li><li>以原NFA的start state作为DFA的start state，对于当前状态中的每一个子状态，对每一个符号做一次推出操作，构造新的状态和推出过程（注意推出的是NFA对应状态的ε闭包，展开求并得到新的状态）</li><li>重复2直到没有新的状态或转换被创建</li><li>DFA中，包含了NFA中accept state的都是accept state</li></ol><blockquote><p> 举个栗子便于理解：</p><p> $(a|b)^*a(a|b|ε)$</p><p> 得到NFA如下图：</p><p> <img src="/images/comp/com-prin2.assets/image-20200308212454788.png" alt="image-20200308212454788" style="zoom:80%;" /></p><p> 对各状态求ε闭包：</p><p> $\overline 1 = {1,2,3,5,8}$<br> $\overline 2 = {2,3,5}$<br> $\overline 3 = {3}$<br> $\overline 4 = {2,3,4,5,7,8}$<br> $\overline 5 = {5}$<br> $\overline 6 = {2,3,5,6,7,8}$<br> $\overline 7 = {2,3,5,7,8}$<br> $\overline 8 = {8}$<br> $\overline 9 = {9,10,12,14,15,16}$<br> $\overline{10} = {10}$<br> $\overline{11} = {11,16}$<br> $\overline{12} = {12}$<br> $\overline{13} = {13,16}$<br> $\overline{14} = {14,15,16}$<br> $\overline{15} = {15,16}$<br> $\overline{16} = {16}​$</p><p> 得到新的状态转换表：</p><p> （例如，从S0中各状态通过a：3-&gt;4, 8-&gt;9，所以S0通过a转移到 {$\overline 4, \overline 9$}，展开如表中所示，其他同理）</p><table><thead><tr><th style="text-align:center">$S’$</th><th style="text-align:center">$S’_a$</th><th style="text-align:center">$S’_b$</th></tr></thead><tbody><tr><td style="text-align:center">S0 = {1,2,3,5,8}</td><td style="text-align:center">S1 = {2,3,4,5,7,8,9,10,12,14,15,16}</td><td style="text-align:center">S2 = {2,3,5,6,7,8}</td></tr><tr><td style="text-align:center">S1 = {2,3,4,5,7,8,9,10,12,14,15,16}</td><td style="text-align:center">S3 = {2,3,4,5,7,8,9,10,11,12,14,15,16}</td><td style="text-align:center">S4 = {2,3,5,6,7,8,13,16}</td></tr><tr><td style="text-align:center">S2 = {2,3,5,6,7,8}</td><td style="text-align:center">S1 = {2,3,4,5,7,8,9,10,12,14,15,16}</td><td style="text-align:center">S2 = {2,3,5,6,7,8}</td></tr><tr><td style="text-align:center">S3 = {2,3,4,5,7,8,9,10,11,12,14,15,16}</td><td style="text-align:center">S3 = {2,3,4,5,7,8,9,10,11,12,14,15,16}</td><td style="text-align:center">S4 = {2,3,5,6,7,8,13,16}</td></tr><tr><td style="text-align:center">S4 = {2,3,5,6,7,8,13,16}</td><td style="text-align:center">S3 = {2,3,4,5,7,8,9,10,11,12,14,15,16}</td><td style="text-align:center">S2 = {2,3,5,6,7,8}</td></tr></tbody></table><p> 画出DFA：</p><p> <img src="/images/comp/com-prin2.assets/image-20200308213027672.png" alt="image-20200308213027672" style="zoom: 60%;" /></p></blockquote><h3 id="DFA的优化（最小化）"><a href="#DFA的优化（最小化）" class="headerlink" title="DFA的优化（最小化）"></a>DFA的优化（最小化）</h3><p>最小化的需求是，每个等价类只能由一个状态来表示，因此这一步要做的就是划分等价类</p><ol><li><p>先根据是否为终止状态分为两类，非终止状态和终止状态</p></li><li><p>在每一类中继续细分，对等价类的要求是，对同一符号，转换到的新状态要属于同一等价类（注意，是同一等价类，可以是该等价类下不同的状态）。因此对于每一类中的每个子状态，对每一个符号进行转换，一旦有转换结果属于不同的类，则将其分在不同的等价类下。</p></li><li>对每一个类重复2，要注意的是，划分完后面的类之后，要回去看一下前面的类是否需要进一步划分（因为可能之前结果在同一类，但在后面被分开了）</li><li>每个等价类取一个状态作为代表，画新的DFA</li></ol><blockquote><p>上一个例子中简化的结果如下图：</p><p><img src="/images/comp/com-prin2.assets/image-20200308213842871.png" alt="image-20200308213842871" style="zoom: 60%;" /></p></blockquote><p>参考：<a href="https://blog.csdn.net/cuiods/article/details/52673154" target="_blank" rel="noopener">here</a></p><p><br></p><h2 id="Lex"><a href="#Lex" class="headerlink" title="Lex"></a>Lex</h2><p><strong>input</strong>: a text file containing regular expressions, together with the actions to be taken when each expression is matched</p><p><strong>output</strong>: Contains C source code defining a procedure yylex that is\</p><p> a table-driven implementation of a DFA corresponding to the regular expressions of the input file, and that   operates like a <strong>getToken</strong> procedure.</p><h3 id="The-format-of-a-Lex-input-file"><a href="#The-format-of-a-Lex-input-file" class="headerlink" title="The format of a Lex input file"></a>The format of a Lex input file</h3><blockquote><p>{definitions}     –&gt; 定义</p><p>%%    –&gt; 分隔符</p><p>{rules}     –&gt; 核心</p><p>%%</p><p>{auxiliary routines}    –&gt; action中用到的函数等</p></blockquote><h4 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h4><p>放在 %{…%} 的省略号部分中（遇到%不会处理，而是原封放入output）</p><p>RE的命名在这里会被定义（因为RE不唯一，命名之后可以用于简化）</p><h4 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h4><p>将RE和将要运行的代码相对应（一对一关系，RE - action）</p><h4 id="Auxiliary-routines"><a href="#Auxiliary-routines" class="headerlink" title="Auxiliary routines"></a>Auxiliary routines</h4><p>函数定义</p><p>“.”可以用作通配符，匹配除换行符外的所有符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">&#x2F;* a Lex program that changes all numbers from decimal to hexadecimal notation,</span><br><span class="line">printing a summary statistic to stdeer</span><br><span class="line">*&#x2F;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line">%&#125;</span><br><span class="line">digit [0-9]</span><br><span class="line">number &#123;digit&#125;+</span><br><span class="line">%%</span><br><span class="line">&#123; number &#125; &#123; int n &#x3D; atoi (yytext);</span><br><span class="line">printf(“%x”, n);</span><br><span class="line">if (n &gt; 9) count ++; &#125;</span><br><span class="line">%%</span><br><span class="line">main( )</span><br><span class="line">&#123; yylex ( );</span><br><span class="line">fprintf(stdeer, “number of replacements &#x3D; %d”, count);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/comp/com-prin2.assets/image-20200308123221931.png&quot; alt=&quot;image-20200308123221931&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;Scann
      
    
    </summary>
    
      <category term="Notes" scheme="https://iris-cyy.github.io/categories/Notes/"/>
    
      <category term="Compilation Principle" scheme="https://iris-cyy.github.io/categories/Notes/Compilation-Principle/"/>
    
    
      <category term="Notes" scheme="https://iris-cyy.github.io/tags/Notes/"/>
    
      <category term="CP" scheme="https://iris-cyy.github.io/tags/CP/"/>
    
  </entry>
  
  <entry>
    <title>【Compilation Principle】 Introduction</title>
    <link href="https://iris-cyy.github.io//Notes/Compilation-Principle/2020-03-04/cp_intro/"/>
    <id>https://iris-cyy.github.io//Notes/Compilation-Principle/2020-03-04/cp_intro/</id>
    <published>2020-03-04T09:21:11.000Z</published>
    <updated>2020-03-10T04:53:59.436Z</updated>
    
    <content type="html"><![CDATA[<p>Compilers: computer languages</p><blockquote><p>Translate one language to another<br>Source language(input) to target language (output)<br>Source language : high-level language c or c++<br>Target language : object code, machine code (machine instruction)<br>一般是从高级语言 -&gt; 低级语言，但是不一定</p></blockquote><p><br></p><h2 id="A-Brief-History-of-Compiler"><a href="#A-Brief-History-of-Compiler" class="headerlink" title="A Brief History of Compiler"></a>A Brief History of Compiler</h2><ul><li><p>Machine language: programs were written in machine language in late 1940s (c706 0000 0002)</p></li><li><p>Assembly language</p><blockquote><p>Assembler</p><p>Defects: difficult  to read/understand, depend on the particular machine</p></blockquote></li><li><p>FORTRAN: Between 1954 and 1957, by IBM, John Backus</p><blockquote><p>完全静态的语言（运行前内存分配就已固定，没有指针 -&gt; 指针式动态内存分配的工具）</p><p>多用于工业控制</p><p>对语言进行层次划分，将语法分为type0, type1, type2, type3，四个层次从0-3互为包含关系（从0-3可以看成是从大到小的同心圆）</p></blockquote></li><li><p>Parsing problem: 1960s and 1970s</p></li><li>Optimization techniques: improve compiler efficiency (时间效率、空间效率)</li><li>Compiler-compilers (parser generator, 语法分析器)</li><li>YACC (yet another compiler-compiler, 语法分析器): 1975, by Steve Johnson for UNIX.</li><li>Lex (词法分析器): 1975 by Mike Lest</li></ul><p><br></p><h2 id="Programs-related-to-compilers"><a href="#Programs-related-to-compilers" class="headerlink" title="Programs related to compilers"></a>Programs related to compilers</h2><ul><li><p>Interpreters</p><p>解释器，与编译器功能相同</p></li><li><p>Assemblers</p><p>汇编器，与编译器配合使用</p><p>source code —&gt;（编译器）—&gt; assembly code —&gt;（汇编器）—&gt; object code</p></li><li><p>Linkers</p><p>连接器（拼接成可执行文件）</p></li><li><p>Loaders</p><p>重定位（相对地址）</p></li><li><p>Preprocessors</p><p>预处理，删除注释、做include和宏定义</p></li><li><p>Editors</p><p>编译器，生成标准文件</p></li><li><p>Debuggers</p><p>调试器</p></li><li><p>Profilers</p><p>手机程序运行中的相关信息，为程序改进提供信息</p></li><li><p>Project managers</p><p>多文件操作（project），引入控制、多人协作</p></li></ul><p><br></p><h2 id="The-Translation-Process"><a href="#The-Translation-Process" class="headerlink" title="The Translation Process"></a>The Translation Process</h2><p><img src="/images/comp/com-prin1.assets/image-20200307101832977.png" alt="image-20200307101832977" style="zoom: 60%;" /></p><blockquote><p><strong>Scanner</strong>：词法分析（lexical analysis）</p><p><strong>Token</strong>：单词、令环（不可分割的最小单位）</p><p><strong>Parser</strong>：语法分析（syntax analysis）</p><p><strong>Syntax tree</strong>：语法树</p><p><strong>Semantic Analyzer</strong>：语义分析器（Semantic analysis）</p><p><strong>Annotated tree</strong>：带注释的树（标注语义信息）</p><p><strong>Source code optimizer</strong>：优化器（源程序代码级优化，依赖源代码特性），从而提高效率</p><p><strong>Intermediate code</strong>：中间代码（m种源代码 -&gt; n种目标代码，有m*n种映射；如果有中间代码，减少至m+n种）</p><p><strong>Code generator</strong>：代码生成器</p><p><strong>Target code</strong>：目标码</p><p><strong>Target code optimizer</strong>：目标码优化，依赖目标码特性</p><p><strong>Literal table</strong>：常量表</p><p><strong>Symbol table</strong>：符号表（重要），用于提升性能</p><p><strong>Error handler</strong>：用于错误处理和错误恢复（容错性）</p></blockquote><h3 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h3><p>词法分析（lexical analysis）</p><p>输入符号流，输出token（不管值）</p><p>同时将标识符放入<code>symbol table</code>，将常量放入<code>literal table</code></p><p><img src="/images/comp/com-prin1.assets/image-20200307124000496.png" alt="image-20200307124000496" style="zoom:55%;" /></p><h3 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h3><p>语法分析（syntax analysis）</p><p>输入符号（token），输出语法树（syntax tree）或解析树（parse tree）</p><p>在语法树中，叶子对应终结符，非叶节点对应非终结符</p><p><strong>Parse Tree</strong>：（具体）</p><p><img src="/images/comp/com-prin1.assets/image-20200307124410124.png" alt="image-20200307124410124" style="zoom:55%;" /></p><p><strong>Syntax Tree</strong>：（抽象，parse tree的压缩）</p><p><img src="/images/comp/com-prin1.assets/image-20200307124856028.png" alt="image-20200307124856028" style="zoom:50%;" /></p><h3 id="Semantic-analyzer"><a href="#Semantic-analyzer" class="headerlink" title="Semantic analyzer"></a>Semantic analyzer</h3><p>语义分析器</p><ul><li>静态语义（static semantics）：包括声明和类型检查（编译时可以确定）</li><li>动态语义（dynamic semantics）</li></ul><p>根据语义信息得到属性（attribute） –&gt; 语义信息语法化</p><p>例如加入“类型”这一语义属性（作用：保证程序安全）</p><p><strong>Annotated Tree</strong>：</p><p><img src="/images/comp/com-prin1.assets/image-20200307145447835.png" alt="image-20200307145447835" style="zoom:55%;" /></p><h3 id="Source-code-optimizer"><a href="#Source-code-optimizer" class="headerlink" title="Source code optimizer"></a>Source code optimizer</h3><p>源代码级优化</p><p>生成中间代码（intermediate code or IR） –&gt; 表示形态主要有三地址码（three-address code）、P-code两种</p><ul><li>三地址码：比较接近高级语言</li><li>P-code：pascal语言的中间代码（接近机器语言）</li></ul><p>会进行例如常量叠加等操作（不同的编译器执行的优化种类和优化阶段位置都会有差异）</p><p><img src="/images/comp/com-prin1.assets/image-20200307151136599.png" alt="image-20200307151136599" style="zoom:50%;" /></p><p><img src="/images/comp/com-prin1.assets/image-20200307150619488.png" alt="image-20200307150619488" style="zoom:55%;" /></p><h3 id="Code-generator"><a href="#Code-generator" class="headerlink" title="Code generator"></a>Code generator</h3><p>输入中间代码，输出机器码（目标机器用的代码）</p><p><img src="/images/comp/com-prin1.assets/image-20200307165109546.png" alt="image-20200307165109546" style="zoom: 50%;" /></p><h3 id="Target-code-optimizer"><a href="#Target-code-optimizer" class="headerlink" title="Target code optimizer"></a>Target code optimizer</h3><p>目标代码级优化</p><ul><li>选择寻址模式，提高性能</li><li>用更快的指令代替慢的（如，用左移代替*2 –&gt; 速度：左移 &gt; 加法 &gt; 乘法）</li><li>去除多余的和不必要的操作</li></ul><p><img src="/images/comp/com-prin1.assets/image-20200307165319770.png" alt="image-20200307165319770" style="zoom:50%;" /></p><p><br></p><h2 id="Major-Data-Structures-In-A-Compiler"><a href="#Major-Data-Structures-In-A-Compiler" class="headerlink" title="Major Data Structures In A Compiler"></a>Major Data Structures In A Compiler</h2><ul><li><p>Tokens<br>可数，可通过定义枚举变量表示</p></li><li><p>Syntax Tree</p><p>每个节点都是一条记录，递归表示parser和semantic analyzer收集到的信息</p></li><li><p>Symbol Table</p><p>符号表。存储标识符信息（函数、变量、常量、数据类型等）</p></li><li><p>Literal Table</p><p>常量表，存储常数、字符串等</p></li><li><p>Intermediate Code</p><p>中间代码</p></li><li><p>Temporary Files</p><p>用临时文件保存中间步骤</p></li></ul><p><br></p><h2 id="Other-Issues"><a href="#Other-Issues" class="headerlink" title="Other Issues"></a>Other Issues</h2><ul><li><p><strong>Analysis</strong>：lexical analysis（词法分析）、syntax analysis（语法分析）、semantic analysis(optimization)（语义分析）</p></li><li><p><strong>Synthesis</strong>：code generation(optimization)（代码生成）</p></li></ul><p>根据源代码和目标代码来划分前端后端：</p><ul><li><strong>Front end</strong>：scanner, parser, senabtic analyzer, intermediate code synthesis</li><li><strong>Back end</strong>：code generator, optimization</li><li><p>（可能有<strong>middle end</strong>，gcc4.0根据中间代码进行优化）</p></li><li><p><strong>Passes</strong>：Passes是相对于其余编译序列化的一个阶段或一组阶段，它在前一阶段完成之前不会启动，并且在任何后续阶段开始之前完成。对于一个程序要分为几个pass来多次处理，每个pass包含若干个阶段，商业级的编译器的pass数一般在30-40以上</p></li><li>Language definition </li><li>Compiler options and interfaces</li><li>Error handling: static error, execution error</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Compilers: computer languages&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Translate one language to another&lt;br&gt;Source language(input) to target language (output)
      
    
    </summary>
    
      <category term="Notes" scheme="https://iris-cyy.github.io/categories/Notes/"/>
    
      <category term="Compilation Principle" scheme="https://iris-cyy.github.io/categories/Notes/Compilation-Principle/"/>
    
    
      <category term="Notes" scheme="https://iris-cyy.github.io/tags/Notes/"/>
    
      <category term="CP" scheme="https://iris-cyy.github.io/tags/CP/"/>
    
  </entry>
  
  <entry>
    <title>关于科学上网</title>
    <link href="https://iris-cyy.github.io//Tricks/2020-02-28/science_online/"/>
    <id>https://iris-cyy.github.io//Tricks/2020-02-28/science_online/</id>
    <published>2020-02-28T09:22:19.000Z</published>
    <updated>2020-02-29T04:59:45.698Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不得不说国庆以来真的越查越严，中间换了有几十个梯子，最长的没撑过半个月（哭），最近甚至平均每三分钟挂掉一个（搭完打开google验证搭成功了，然后打开gmail收一下邮件，然后就没有然后了）。于是意识到ss不香了，不得不另辟蹊径。然后在十五分钟前，我终于时隔五个月又一次成功登上ins🎉🎉🎉</p><p>此处应有配图<br>我太难了.jpg</p></blockquote><p><br></p><p>下面是正文</p><p>参考了许多别的博主，但鉴于这些文章总是会不定期消失，所以还是自己总结一篇更靠谱一点：）</p><p><br></p><h2 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h2><p>首先要买到能用的VPS（vultr大法好</p><p>除了vultr还有digitalocean、linode等等 就不详细说了，聪明的你一定能搞定</p><p><a href="http://www.nocnhost.com/vultr-vs-digitalocean-vs-linode?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">这里有一篇别人写的blog比较上述三家VPS</a></p><p>get到能用的vps之后，记录下ip和password</p><p>先连接，可以直接终端ssh也可以用别的软件（putty等）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssh root@&lt;ip&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如 ssh root@192.168.99.99</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果跳出来确认，输yes就行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按要求输入密码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果跳出来22端口连接错误，那就说明这个ip不行，重新换一个</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果成功会跳出来:</span></span><br><span class="line">root@vultr:~#</span><br></pre></td></tr></table></figure><p>下面开始搭梯子</p><p>我试过比较成功的有ss和v2ray两种搭法，下面分别介绍</p><p><br></p><h2 id="SS"><a href="#SS" class="headerlink" title="SS"></a>SS</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>这个方法我用了两年，最近挂得频繁才开始摸索新的搭法。</p><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>安装ss服务端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install shadowsocks</span><br><span class="line"><span class="meta">#</span><span class="bash"> 中间的确认步骤输y</span></span><br></pre></td></tr></table></figure><p>等它安装好之后编辑配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/shadowsocks/config.json</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进去之后输i进入--INSERT——模式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置完成之后按ESC退出——INSERT——模式，输入:wq就可以保存并退出</span></span><br></pre></td></tr></table></figure><p>可能有初始配置也可能没有，大概配置成下面这样就行了（端口可以自己配置，之后如果遇到服务器挂掉，排查完不是ip整个不行了的话，可以到这边来改端口）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>:<span class="string">"服务器的ip"</span>, </span><br><span class="line">  <span class="attr">"server_port"</span>:<span class="number">8000</span>, </span><br><span class="line">  <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>, </span><br><span class="line">  <span class="attr">"local_port"</span>:<span class="number">1080</span>, </span><br><span class="line">  <span class="attr">"password"</span>:<span class="string">"自定义的密码"</span>, </span><br><span class="line">  <span class="attr">"timeout"</span>:<span class="number">300</span>, </span><br><span class="line">  <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>, </span><br><span class="line">  <span class="attr">"fast_open"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"workers"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks/config.json start &amp;</span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>下载shadowsocks客户端并按照服务器配置（MacOS、Windows、Linux、Android、iOS等都有对应的版本）</p><p>据说<a href="https://shadowsocks.org/en/download/clients.html" target="_blank" rel="noopener">这里</a>可以下载，但我应该不是从这儿下的</p><p>有个github开源地址，也有民间版本的下载链接，聪明的你一定可以找到</p><p>配置完大概长这样：</p><p><img src="/images/tricks/scienceonline.assets/image-20200228175540635.png" alt="image-20200228175540635"></p><p>确定之后开启客户端，推荐使用PAC自动模式</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>这个方法的好处在于可以配置多用户模式（也许前面一个方法也可以，没有尝试）</p><p>参考<a href="https://blog.csdn.net/m0_38031488/article/details/90666355" target="_blank" rel="noopener">这篇博客</a>，复读一下以防404</p><h4 id="服务器-1"><a href="#服务器-1" class="headerlink" title="服务器"></a>服务器</h4><p>开启加速优化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N — no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;&amp; bash serverspeeder-all.sh</span><br></pre></td></tr></table></figure><p>安装ss</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">下载</span></span><br><span class="line">wget — no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">更改权限</span></span><br><span class="line">chmod 777 shadowsocks.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">开始安装</span></span><br><span class="line">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure><p>按要求输入密码、端口（大于1000）、加密方式（选择对应数字，推荐7号，aes-256-cfb），按指令完成搭建</p><p>下面的步骤可供选择</p><p>有需求配置多用户使用（多端口）的话进入以下步骤，没有需求则到这里就大功告成</p><p>创建配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><p>修改为多用户模式，举例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"::"</span>,</span><br><span class="line">    <span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"port_password"</span>:&#123;</span><br><span class="line">         <span class="attr">"9000"</span>:<span class="string">"12345"</span>,</span><br><span class="line">         <span class="attr">"9001"</span>:<span class="string">"12345"</span>,</span><br><span class="line">         <span class="attr">"9002"</span>:<span class="string">"12345"</span>,</span><br><span class="line">         <span class="attr">"9003"</span>:<span class="string">"12345"</span>,</span><br><span class="line">         <span class="attr">"9004"</span>:<span class="string">"12345"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中server的初始值是0.0.0.0，设置成这样方便ipv6连接，也可以不改</p><p>port和password都可以自定义</p><p>保存配置之后重启ss</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/shadowsocks restart</span><br></pre></td></tr></table></figure><p>完成✅</p><p>客户端的配置和方法一一样</p><p><br></p><h2 id="v2ray"><a href="#v2ray" class="headerlink" title="v2ray"></a>v2ray</h2><p>鉴于最近ss普遍不行，我又翻了很多博客找到v2ray的搭建方法</p><p>请参考<a href="https://www.codercto.com/a/22204.html?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">这篇博客</a></p><p>科学爱国，嗯，科学爱国</p><p>默念100遍社会主义核心价值观</p><p>以下是基础版本的复读</p><h3 id="服务器-2"><a href="#服务器-2" class="headerlink" title="服务器"></a>服务器</h3><p>同样，先安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)</span><br></pre></td></tr></table></figure><p>等安装完之后，记录跳出来的<strong>PORT</strong>和<strong>UUID</strong>（划重点）</p><p>如果提示缺少命令可以先升级一下apt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果没有提示任何错误，直接安装完成了，请跳过这步</span></span><br><span class="line">yum update</span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure><p>安装完成后开启运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service v2ray start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面这个命令可以用来查看状态，如果显示running则开启成功</span></span><br><span class="line">service v2ray status</span><br></pre></td></tr></table></figure><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><p>下载对应操作系统的v2ray</p><p><a href="https://github.com/v2ray/v2ray-core/releases" target="_blank" rel="noopener">🔗1</a> （github链接）</p><p><a href="https://www.v2ray.com" target="_blank" rel="noopener">🔗2</a> （这个有很大概率是坏的）</p><p><a href="https://tlanyan.me/v2ray-clients-download/" target="_blank" rel="noopener">🔗3</a> （我从这里下的）</p><p>配置config.json如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    <span class="attr">"inbound"</span>: &#123;      </span><br><span class="line">        <span class="attr">"port"</span>: <span class="number">1080</span>,      </span><br><span class="line">        <span class="attr">"listen"</span>: <span class="string">"127.0.0.1"</span>,      </span><br><span class="line">        <span class="attr">"protocol"</span>: <span class="string">"socks"</span>,      </span><br><span class="line">        <span class="attr">"settings"</span>: &#123;        </span><br><span class="line">            <span class="attr">"auth"</span>: <span class="string">"noauth"</span>        </span><br><span class="line">            <span class="string">"udp"</span>: <span class="literal">true</span>      </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;,    </span><br><span class="line">    <span class="attr">"outbound"</span>: &#123;      </span><br><span class="line">        <span class="attr">"protocol"</span>: <span class="string">"vmess"</span>,      </span><br><span class="line">        <span class="attr">"settings"</span>: &#123;          </span><br><span class="line">            <span class="attr">"vnext"</span>: [          </span><br><span class="line">                &#123;            </span><br><span class="line">                    <span class="attr">"address"</span>: <span class="string">"服务器的ip"</span>,           </span><br><span class="line">                    <span class="attr">"port"</span>: 记录的port,            </span><br><span class="line">                    <span class="attr">"users"</span>: [              </span><br><span class="line">                        &#123;                </span><br><span class="line">                            <span class="attr">"id"</span>: <span class="string">"记录的UUID"</span>,       </span><br><span class="line">                            <span class="attr">"alterId"</span>: <span class="number">64</span>              </span><br><span class="line">                        &#125;            </span><br><span class="line">                    ]          </span><br><span class="line">                &#125;        </span><br><span class="line">            ]      </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="string">"outboundDetour"</span>: [    </span><br><span class="line">    &#123;      </span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line"><span class="attr">"tag"</span>: <span class="string">"direct"</span>    </span><br><span class="line">&#125;  </span><br><span class="line">],  </span><br><span class="line"><span class="attr">"routing"</span>: &#123;    </span><br><span class="line">        <span class="attr">"strategy"</span>: <span class="string">"rules"</span>,    </span><br><span class="line">        <span class="attr">"settings"</span>: &#123;      </span><br><span class="line">            <span class="attr">"domainStrategy"</span>: </span><br><span class="line">            <span class="string">"IPIfNonMatch"</span>,      </span><br><span class="line">            <span class="attr">"rules"</span>: [        </span><br><span class="line">                &#123;          </span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"geoip:private"</span>,          </span><br><span class="line">                    <span class="attr">"outboundTag"</span>: <span class="string">"direct"</span>        </span><br><span class="line">                &#125;,        </span><br><span class="line">                &#123;          </span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"geosite:cn"</span>,          </span><br><span class="line">                    <span class="attr">"outboundTag"</span>: <span class="string">"direct"</span>        </span><br><span class="line">                &#125;,        </span><br><span class="line">                &#123;          </span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"geoip:cn"</span>,          </span><br><span class="line">                    <span class="attr">"outboundTag"</span>: <span class="string">"direct"</span>        </span><br><span class="line">                &#125;      </span><br><span class="line">            ]    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="string">"mux"</span>: &#123;    </span><br><span class="line">        <span class="attr">"enabled"</span>: <span class="literal">true</span>,    </span><br><span class="line">        <span class="attr">"concurrency"</span>: <span class="number">8</span>  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以不配置，直接在运行软件的时候在页面里配置也成，输入对应IP、port、ID就可</p><p>到这里大功告成</p><p>下面讲手机端的配置</p><p>Android推荐用BifrostV作为客户端，下载链接在<a href="https://www.codercto.com/a/22204.html?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">这里</a></p><p>手动配置，其中顶端选择VMess，Host填IP，Port填port，UserID填UUID，配置完保存退出，开启连接，完事儿</p><p>iOS俺也不会</p><p><br></p><p>下面是几个介绍进阶版配置的链接，收藏了等于学过了，嗯</p><p><a href="https://tlanyan.me/recovery-blocked-ip/" target="_blank" rel="noopener">拯救被墙IP</a></p><p><a href="http://www.nocnhost.com/vultr-vs-digitalocean-vs-linode?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">伪装成HTTP</a></p><p><br></p><p>最后补一句，chorme有一个插件，速度很慢但好像不太容易挂（虽然浏览器会定期自动删掉这个插件</p><p>应急的时候可以尝试</p><p><br></p><p>先到这儿，希望永远不要有研究新方法的需求</p><p>祈祷一下这回梯子能留久一点</p><p>刷ins去了 bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;不得不说国庆以来真的越查越严，中间换了有几十个梯子，最长的没撑过半个月（哭），最近甚至平均每三分钟挂掉一个（搭完打开google验证搭成功了，然后打开gmail收一下邮件，然后就没有然后了）。于是意识到ss不香了，不得不另辟蹊径。然后在十五分钟前，
      
    
    </summary>
    
      <category term="Tricks" scheme="https://iris-cyy.github.io/categories/Tricks/"/>
    
    
      <category term="Tricks" scheme="https://iris-cyy.github.io/tags/Tricks/"/>
    
  </entry>
  
  <entry>
    <title>【Python】Basis</title>
    <link href="https://iris-cyy.github.io//Notes/Python/2020-02-25/python_basis/"/>
    <id>https://iris-cyy.github.io//Notes/Python/2020-02-25/python_basis/</id>
    <published>2020-02-25T10:09:53.000Z</published>
    <updated>2020-06-01T11:18:18.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li><p>数字、字母、下划线</p></li><li><p>必须以字母或下划线开头，不能以数字开头</p></li><li><p>大小写敏感</p></li><li><p>不能是关键字（保留字）</p><ul><li><p>Python2 的关键字：<br><img src="/images/python/python-basis.assets/image-20200225182820298.png" alt="image-20200225182820298"></p></li><li><p>Python3 的关键字<br><img src="/images/python/python-basis.assets/image-20200225183717669.png" alt="image-20200225183717669"></p></li></ul></li></ul><p>变量将名字和对象关联起来，赋值操作并不会实际复制值，只是为数据对象取相关名字。名字是对象的引用而不是对象本身。</p><p>小整数（-5 ～ 256）直接作为对象存储，地址固定，而其他的整数地址要临时分配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">7</span></span><br><span class="line">b = <span class="number">7</span></span><br><span class="line">id(a) == id(b) <span class="comment">#true</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">1000</span></span><br><span class="line">d = <span class="number">1000</span></span><br><span class="line">id(c) == id(d) <span class="comment">#false</span></span><br></pre></td></tr></table></figure><p><code>del()</code>函数用于删除变量</p><p><br></p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p><code>input()</code>：读入一整行作为字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &lt;变量&gt; = input(&lt;提示性文字&gt;)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>input(<span class="string">"请输入："</span>)</span><br><span class="line">请输入：</span><br></pre></td></tr></table></figure><p>输入integer</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = int(input())</span><br><span class="line"><span class="comment"># 其实int()是一个方法，完整表示是class int(x, base=10)</span></span><br><span class="line"><span class="comment"># x是字符串或者数字，base是进制，默认是十进制</span></span><br></pre></td></tr></table></figure><p>输入list</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = list(map(int, input.split()))</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = input.split()</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'3//11//2018'</span>.split(<span class="string">'/'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="string">'3'</span>, <span class="string">''</span>, <span class="string">'11'</span>, <span class="string">''</span>, <span class="string">'2018'</span>]</span><br></pre></td></tr></table></figure><p>同时为多个变量赋值</p><p>用<code>split()</code>函数，用于把字符串按” “分开成一个list（每个元素都是字符串），也可以按照其他元素分开，给<code>split()</code>参数即可，例如3#4#5按#分开，用<code>split(&#39;#&#39;)</code>（即<code>split()</code>的参数默认为’ ‘）</p><p>在同行用空格分格读取三个整数的方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = map(int, input().split())</span><br></pre></td></tr></table></figure><p>另外一种trick</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = eval(input()) <span class="comment"># 适用输入类似1，2，3情况（eval为直接去除字符串两边的“”，相当于三对三赋值）</span></span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><code>print()</code>：以字符形式输出变量，可以输出各种类型变量的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line"><span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b, c = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b, c, <span class="number">5</span>)</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>更改<code>end</code>参数可以做到不换行输出等（<code>end</code>默认是<code>\n</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">3</span>, end=<span class="string">''</span>)</span><br><span class="line">print(<span class="number">4</span>, end=<span class="string">''</span>)</span><br><span class="line"><span class="comment">#输出34</span></span><br></pre></td></tr></table></figure><p>通过<code>%</code>来选择要输出的变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># "&lt;格式字符串&gt;" %(&lt;输出对象&gt;, &lt;输出对象&gt; ...)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"Celsuis: %3d Fahr: %6.1f"</span> %(celsuis, fahr))</span><br></pre></td></tr></table></figure><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><h5 id=""><a href="#" class="headerlink" title="%"></a><code>%</code></h5><p><img src="/images/python/python-basis.assets/image-20200317111456498.png" alt="image-20200317111456498"></p><p>整数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%o'</span> %<span class="number">20</span>) <span class="comment"># %o 八进制</span></span><br><span class="line"><span class="number">2</span> <span class="number">24</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%d'</span> %<span class="number">20</span>) <span class="comment"># %d 十进制</span></span><br><span class="line"><span class="number">4</span> <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%x'</span> %<span class="number">20</span>) <span class="comment"># %x 十六进制</span></span><br><span class="line"><span class="number">6</span> <span class="number">14</span></span><br></pre></td></tr></table></figure><p>浮点数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %f ——保留小数点后面六位有效数字</span></span><br><span class="line"><span class="comment"># 　　%.3f，保留3位小数位</span></span><br><span class="line"><span class="comment"># %e ——保留小数点后面六位有效数字，指数形式输出</span></span><br><span class="line"><span class="comment"># 　　%.3e，保留3位小数位，使用科学计数法</span></span><br><span class="line"><span class="comment"># %g ——在保证六位有效数字的前提下，使用小数方式，否则使用科学计数法</span></span><br><span class="line"><span class="comment"># 　　%.3g，保留3位有效数字，使用小数或科学计数法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%f'</span> % <span class="number">1.11</span>)  <span class="comment"># 默认保留6位小数</span></span><br><span class="line"><span class="number">1.110000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%.1f'</span> % <span class="number">1.11</span>)  <span class="comment"># 取1位小数</span></span><br><span class="line"><span class="number">1.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%e'</span> % <span class="number">1.11</span>)  <span class="comment"># 默认6位小数，用科学计数法</span></span><br><span class="line"><span class="number">1.110000e+00</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%.3e'</span> % <span class="number">1.11</span>)  <span class="comment"># 取3位小数，用科学计数法</span></span><br><span class="line"><span class="number">1.110e+00</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%g'</span> % <span class="number">1111.1111</span>)  <span class="comment"># 默认6位有效数字</span></span><br><span class="line"><span class="number">1111.11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%.7g'</span> % <span class="number">1111.1111</span>)  <span class="comment"># 取7位有效数字</span></span><br><span class="line"><span class="number">1111.111</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%.2g'</span> % <span class="number">1111.1111</span>)  <span class="comment"># 取2位有效数字，自动转换为科学计数法</span></span><br><span class="line"><span class="number">1.1e+03</span></span><br></pre></td></tr></table></figure><p>字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %s</span></span><br><span class="line"><span class="comment"># %10s——右对齐，占位符10位</span></span><br><span class="line"><span class="comment"># %-10s——左对齐，占位符10位</span></span><br><span class="line"><span class="comment"># %.2s——截取2位字符串</span></span><br><span class="line"><span class="comment"># %10.2s——10位占位符，截取两位字符串</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%s'</span> % <span class="string">'hello world'</span>)  <span class="comment"># 字符串输出</span></span><br><span class="line">hello world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%20s'</span> % <span class="string">'hello world'</span>)  <span class="comment"># 右对齐，取20位，不够则补位</span></span><br><span class="line">         hello world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%-20s'</span> % <span class="string">'hello world'</span>)  <span class="comment"># 左对齐，取20位，不够则补位</span></span><br><span class="line">hello world         </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%.2s'</span> % <span class="string">'hello world'</span>)  <span class="comment"># 取2位</span></span><br><span class="line">he</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%10.2s'</span> % <span class="string">'hello world'</span>)  <span class="comment"># 右对齐，取2位</span></span><br><span class="line">        he</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%-10.2s'</span> % <span class="string">'hello world'</span>)  <span class="comment"># 左对齐，取2位</span></span><br><span class="line">he</span><br></pre></td></tr></table></figure><h5 id="format-函数"><a href="#format-函数" class="headerlink" title="format()函数"></a><code>format()</code>函数</h5><p>基本格式：<code>str.format()</code></p><p>它的一般格式是：<code>{&lt;索引&gt;:&lt;填充字符&gt;&lt;对齐方式&gt;&lt;宽度.精度&gt;&lt;格式&gt;}</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;0:*&gt;10&#125;'</span>.format(<span class="number">10</span>) <span class="comment">#右对齐</span></span><br><span class="line"><span class="string">'********10'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;0:*&lt;10&#125;'</span>.format(<span class="number">10</span>) <span class="comment">#左对齐</span></span><br><span class="line"><span class="string">'10********'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;0:*^10&#125;'</span>.format(<span class="number">10</span>) <span class="comment">#居中对齐</span></span><br><span class="line"><span class="string">'****10****'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;0:.2f&#125;'</span>.format(<span class="number">1</span>/<span class="number">3</span>)</span><br><span class="line"><span class="string">'0.33'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;0:b&#125;'</span>.format(<span class="number">10</span>) <span class="comment">#二进制</span></span><br><span class="line"><span class="string">'1010'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;0:o&#125;'</span>.format(<span class="number">10</span>) <span class="comment">#八进制</span></span><br><span class="line"><span class="string">'12'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;0:x&#125;'</span>.format(<span class="number">10</span>) <span class="comment">#16进制</span></span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;:,&#125;'</span>.format(<span class="number">12345678901</span>) <span class="comment">#千分位格式化</span></span><br><span class="line"><span class="string">'12,345,678,901'</span></span><br></pre></td></tr></table></figure><p>位置匹配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(format(<span class="number">57.467645</span>, <span class="string">".3f"</span>))</span><br><span class="line"><span class="number">57.468</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;&#125; &#123;&#125;'</span>.format(<span class="string">'hello'</span>,<span class="string">'world'</span>))  <span class="comment"># 不带字段</span></span><br><span class="line">hello world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;0&#125; &#123;1&#125;'</span>.format(<span class="string">'hello'</span>,<span class="string">'world'</span>))  <span class="comment"># 带数字编号</span></span><br><span class="line">hello world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;0&#125; &#123;1&#125; &#123;0&#125;'</span>.format(<span class="string">'hello'</span>,<span class="string">'world'</span>))  <span class="comment"># 打乱顺序</span></span><br><span class="line">hello world hello</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;1&#125; &#123;1&#125; &#123;0&#125;'</span>.format(<span class="string">'hello'</span>,<span class="string">'world'</span>))</span><br><span class="line">world world hello</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;a&#125; &#123;tom&#125; &#123;a&#125;'</span>.format(tom=<span class="string">'hello'</span>,a=<span class="string">'world'</span>))  <span class="comment"># 带关键字</span></span><br><span class="line">world hello world</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;&#125; and &#123;&#125;'</span>.format(<span class="string">'hello'</span>,<span class="string">'world'</span>))  <span class="comment"># 默认左对齐</span></span><br><span class="line">hello <span class="keyword">and</span> world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;:10s&#125; and &#123;:&gt;10s&#125;'</span>.format(<span class="string">'hello'</span>,<span class="string">'world'</span>))  <span class="comment"># 取10位左对齐，取10位右对齐</span></span><br><span class="line">hello      <span class="keyword">and</span>      world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;:^10s&#125; and &#123;:^10s&#125;'</span>.format(<span class="string">'hello'</span>,<span class="string">'world'</span>))  <span class="comment"># 取10位中间对齐</span></span><br><span class="line">  hello    <span class="keyword">and</span>   world   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;&#125; is &#123;:.2f&#125;'</span>.format(<span class="number">1.123</span>,<span class="number">1.123</span>))  <span class="comment"># 取2位小数</span></span><br><span class="line"><span class="number">1.123</span> <span class="keyword">is</span> <span class="number">1.12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;0&#125; is &#123;0:&gt;10.2f&#125;'</span>.format(<span class="number">1.123</span>))  <span class="comment"># 取2位小数，右对齐，取10位</span></span><br><span class="line"><span class="number">1.123</span> <span class="keyword">is</span>       <span class="number">1.12</span></span><br></pre></td></tr></table></figure><p>多种格式化：</p><ul><li>‘b’ - 二进制。将数字以2为基数进行输出。</li><li>‘c’ - 字符。在打印之前将整数转换成对应的Unicode字符串。</li><li>‘d’ - 十进制整数。将数字以10为基数进行输出。</li><li>‘o’ - 八进制。将数字以8为基数进行输出。</li><li>‘x’ - 十六进制。将数字以16为基数进行输出，9以上的位数用小写字母。</li><li>‘e’ - 幂符号。用科学计数法打印数字。用’e’表示幂。</li><li>‘g’ - 一般格式。将数值以fixed-point格式输出。当数值特别大的时候，用幂形式打印。</li><li>‘n’ - 数字。当值为整数时和’d’相同，值为浮点数时和’g’相同。不同的是它会根据区域设置插入数字分隔符。</li><li>‘%’ - 百分数。将数值乘以100然后以fixed-point(‘f’)格式打印，值后面会有一个百分号。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;0:b&#125;'</span>.format(<span class="number">3</span>))</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;:c&#125;'</span>.format(<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;:d&#125;'</span>.format(<span class="number">20</span>))</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;:o&#125;'</span>.format(<span class="number">20</span>))</span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;:x&#125;'</span>.format(<span class="number">20</span>))</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;:e&#125;'</span>.format(<span class="number">20</span>))</span><br><span class="line"><span class="number">2.000000e+01</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;:g&#125;'</span>.format(<span class="number">20.1</span>))</span><br><span class="line"><span class="number">20.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;:f&#125;'</span>.format(<span class="number">20</span>))</span><br><span class="line"><span class="number">20.000000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;:n&#125;'</span>.format(<span class="number">20</span>))</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;:%&#125;'</span>.format(<span class="number">20</span>))</span><br><span class="line"><span class="number">2000.000000</span>%</span><br></pre></td></tr></table></figure><blockquote><p>格式化输出的做法还挺复杂的，以后写码的时候再具体看吧 ：）</p></blockquote><p><br></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>python没有char没有double，分别用str和float覆盖了</p><p><code>type()</code>可以用来获得数据类型</p><p>True是1，False是0（做算数的时候可以替换，但是<code>type(True)</code>是<code>&lt;class &#39;bool&#39;</code>）</p><h3 id="一些内置的类型转换函数"><a href="#一些内置的类型转换函数" class="headerlink" title="一些内置的类型转换函数"></a>一些内置的类型转换函数</h3><p><code>bool()</code> <code>int()</code> <code>float()</code> <code>str()</code> <code>complex()</code>就不多说了，会自动去掉前后空格、前置0等（但数据中间不能有空格）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">123</span>)</span><br><span class="line"><span class="string">'123'</span></span><br></pre></td></tr></table></figure><p><code>chr()</code>返回整数对应的Unicode字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">65</span>)</span><br><span class="line"><span class="string">'A'</span></span><br></pre></td></tr></table></figure><p><code>ord()</code> 返回Unicode字符对应的整数</p><p>进制转换：<code>bin()</code> <code>oct()</code> <code>hex()</code>（输出是str类型），int可用作转为十进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bin(<span class="number">3</span>)</span><br><span class="line"><span class="string">'0b11'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">"35"</span>, <span class="number">8</span>) <span class="comment">#把8进制的35转为十进制</span></span><br><span class="line"><span class="number">29</span></span><br></pre></td></tr></table></figure><p><code>list()</code></p><h3 id="整数-int"><a href="#整数-int" class="headerlink" title="整数 int"></a>整数 int</h3><ul><li>二进制：0b或0B</li><li>八进制：0o或0O</li><li>十进制：0x或0X</li></ul><p>64位机器可以表示的最大整数是9223372036854775807（但超过这个范围还是可以被表示）</p><h3 id="浮点数-float"><a href="#浮点数-float" class="headerlink" title="浮点数 float"></a>浮点数 float</h3><p>科学计数法：如<code>1.23e9</code>表示$1.23 \times10^9$，<code>1.2e-5</code>表示0.000012（e前后没有空格，e后面的数字是整数）</p><p>浮点数的表达有误差，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2.1</span><span class="number">-2.0</span></span><br><span class="line"><span class="number">0.10000000000000009</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3.2</span>%<span class="number">2</span></span><br><span class="line"><span class="number">1.2000000000000002</span></span><br></pre></td></tr></table></figure><p>可以用<code>sys.float_info</code>查看浮点数信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.float_info</span><br><span class="line">sys.float_info(max=<span class="number">1.7976931348623157e+308</span>, max_exp=<span class="number">1024</span>, max_10_exp=<span class="number">308</span>, min=<span class="number">2.2250738585072014e-308</span>, min_exp=<span class="number">-1021</span>, min_10_exp=<span class="number">-307</span>, dig=<span class="number">15</span>, mant_dig=<span class="number">53</span>, epsilon=<span class="number">2.220446049250313e-16</span>, radix=<span class="number">2</span>, rounds=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p><code>&lt;class &#39;complex&#39;&gt;</code></p><p><code>&lt;real&gt; + &lt;image&gt; j</code> 可以是J或者j</p><p>实部虚部的数据类型都是float</p><p>用<code>complex()</code>函数创建，<code>real</code>方法取实部，<code>imag</code>方法取虚部</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = complex(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">(<span class="number">1</span>+<span class="number">2j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.real</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.imag</span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>方法conjugate返回复数的共轭复数</p><p>$abs(a+bj) = \sqrt{a^2+b^2}$</p><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><p>包含字符串（string）、列表（list）、元组（tuple）等</p><p><a href="https://iris-cyy.github.io/Notes/Python/2020-03-17/python_sequence/">HERE</a></p><p><br></p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>python中没有++，但是可以用+=</p><p><code>sum()</code>可以给list求和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(range(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p><code>%</code>模，可以用作浮点数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3.4</span>%<span class="number">2</span></span><br><span class="line"><span class="number">1.4</span></span><br><span class="line"><span class="comment"># 3.4 - 1 * 2 = 1.4</span></span><br><span class="line"><span class="comment"># 但可能会有不精确问题，例如3.2%2=1.2000000000000002</span></span><br></pre></td></tr></table></figure><p><code>/</code>默认是浮点数除法，<code>//</code>默认是整数除法（向下取整，但如果有一个为float则是取整后的float）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span>/<span class="number">3</span></span><br><span class="line"><span class="number">1.6666666666666667</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span>/<span class="number">2</span></span><br><span class="line"><span class="number">2.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span>//<span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span>//<span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">32.2</span>//<span class="number">6</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">-3</span>//<span class="number">2</span></span><br><span class="line"><span class="number">-2</span></span><br></pre></td></tr></table></figure><p><code>math.sqrt()</code>或<code>**0.5</code>可以开根号（float类）</p><p>乘方可以用<code>pow()</code>或者<code>**</code></p><p><code>**</code> 运算顺序<u>从右往左</u>，<code>3**2**3</code>先算<code>2**3</code>再算<code>3**8</code></p><p><code>round(x)</code>返回浮点数x的四舍五入的值，<code>round(x,n)</code> 返回浮点数x的四舍五入的小数点后的n位数值</p><blockquote><p>其实是四舍六入五成双。1~4舍去， 6~9进位，当5时，如果5后面还有数字则进位，如果5后面没有数字的情况下，5前面的数字偶数则进位，5前面的数字是奇数则舍去。</p><p>n=0表示精确到个位，-1表示十位，负数以此类推</p></blockquote><p>$ln$：<code>math.log()</code></p><p>$log_{10}$：<code>math.log10()</code></p><p>$log_2$：<code>math.log2()</code></p><p>两个数字之间<code>and</code>，值为后面一个数字（除非有0）</p><p><code>math</code>中的常用函数</p><p><img src="../../../../../../images/python/python-basis.assets/image-20200303103254420.png" width=500></p><p>比大小可以连着来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>&lt;<span class="number">3</span>&lt;<span class="number">5</span> <span class="comment"># 1&lt;3 and 3&lt;5</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>&lt;<span class="number">5</span>&gt;<span class="number">2</span> <span class="comment"># 1&lt;5 and 5&gt;2</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>逻辑运算符，第一个条件符合就不用算第二个（第二个里面有error不会报）</p><p>逻辑运算符的优先级：not &gt; and &gt; or</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span> <span class="keyword">and</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>通常一行一条，如一行中有多条，则用分号（;）分开，如果语句太长要跨行，可以续行符（\）跨行表示一个语句</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>不需要事先声明变量名及其类型，直接赋值即可创建各种类型的对象变量</p><p>在c中对变量的赋值，是直接把值给变量，而在python中，变量相当于一个标签，指向一个值。</p><p>所以在python中可以进行同步赋值交换变量的值，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,b = b,a <span class="comment"># 交换变量的值（把a的值给b，把b的值给a）</span></span><br></pre></td></tr></table></figure><h4 id="单变量赋值"><a href="#单变量赋值" class="headerlink" title="单变量赋值"></a>单变量赋值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>k = x + y <span class="comment"># k = 3</span></span><br></pre></td></tr></table></figure><h4 id="序列赋值"><a href="#序列赋值" class="headerlink" title="序列赋值"></a>序列赋值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x,y = <span class="number">4</span>,<span class="number">8</span> <span class="comment"># x = 4, y = 8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b = <span class="string">"34"</span> <span class="comment"># a = 3, b = 4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b = <span class="string">"345"</span> <span class="comment"># error</span></span><br></pre></td></tr></table></figure><h4 id="不等长序列赋值"><a href="#不等长序列赋值" class="headerlink" title="不等长序列赋值"></a>不等长序列赋值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i, *j = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment"># i = 1, j = [2,3], i是int，j是list（注意j前面的*不能漏）</span></span><br></pre></td></tr></table></figure><h4 id="复合赋值"><a href="#复合赋值" class="headerlink" title="复合赋值"></a>复合赋值</h4><p>*=， +=， -= …</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>if-else，注意冒号和缩进，语句块要对齐</p><p>条件表达式：类似if-else，三元</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = <span class="number">10</span> <span class="keyword">if</span> x &gt; <span class="number">20</span> <span class="keyword">else</span> <span class="number">30</span> <span class="comment"># if x &gt; 20, y = 10; else y = 30</span></span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;container&gt;</span><br><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;list&gt;</span><br><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> range(&lt;value&gt;)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">range(start, stop, step)</span><br><span class="line"><span class="comment"># 左闭右开，start默认为0，step默认为1，可以为负</span></span><br><span class="line"><span class="comment"># 如果省略了start，必须也省略step</span></span><br></pre></td></tr></table></figure><p>while-else：通常和break配合使用，else后面跟能够在循环正常结束时可以执行的操作（如果break则不执行else）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> i &lt; a:</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;h3 id=&quot;标识符&quot;&gt;&lt;a href=&quot;#标识符&quot; class=&quot;headerlink&quot; title=&quot;标识符&quot;&gt;&lt;/a&gt;标识符&lt;/h3&gt;&lt;u
      
    
    </summary>
    
      <category term="Notes" scheme="https://iris-cyy.github.io/categories/Notes/"/>
    
      <category term="Python" scheme="https://iris-cyy.github.io/categories/Notes/Python/"/>
    
    
      <category term="Notes" scheme="https://iris-cyy.github.io/tags/Notes/"/>
    
      <category term="Python" scheme="https://iris-cyy.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【Python】Introduction</title>
    <link href="https://iris-cyy.github.io//Notes/Python/2020-02-25/python_intro/"/>
    <id>https://iris-cyy.github.io//Notes/Python/2020-02-25/python_intro/</id>
    <published>2020-02-25T09:50:55.000Z</published>
    <updated>2020-02-26T03:44:13.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>文本编码，二进制编码表示字母、数字、专门符号</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>业界标准，跨语言、跨平台（可表示汉字）</p><p>可变字节不可变长</p><p>用”\u”表示Unicode码</p><p><a href="https://unicode-table.com" target="_blank" rel="noopener">Unicode字符与编码对照表</a></p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>针对Unicode的<u>可变长度</u>字符编码</p><p>并非存储器中编码，使用时把Unicode字符转换为UTF-8</p><p>每一个ASCII字符有一个UTF-8编码，正好与8位ASCII编码一样</p><p><u>Python3默认为UTF-8编码</u></p><p>输出编码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(s.encode(<span class="string">"utf-8"</span>)) <span class="comment"># s为字符串，输出的是每个字符对应的utf-8编码连起来</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>面向对象</p><p>解释型语言</p><p>Python官网：<a href="https://www.python.org" target="_blank" rel="noopener">https://www.python.org</a></p><p>一些IDE：</p><ul><li><a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">PyCharm</a></li><li><a href="https://github.com/spyder-ide/spyder" target="_blank" rel="noopener">Spyder</a></li><li><p><a href="https://thonny.org/" target="_blank" rel="noopener">Thonny</a></p></li><li><p><a href="https://www.sublimetext.com" target="_blank" rel="noopener">Sublime Text</a></p></li><li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VS Code</a></li></ul><p>在线环境：</p><ul><li><a href="https://clin.icourse163.org/py" target="_blank" rel="noopener">https://clin.icourse163.org/py</a></li><li><a href="http://pythontutor.com/" target="_blank" rel="noopener">http://pythontutor.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编码&quot;&gt;&lt;a href=&quot;#编码&quot; class=&quot;headerlink&quot; title=&quot;编码&quot;&gt;&lt;/a&gt;编码&lt;/h2&gt;&lt;h3 id=&quot;ASCII&quot;&gt;&lt;a href=&quot;#ASCII&quot; class=&quot;headerlink&quot; title=&quot;ASCII&quot;&gt;&lt;/a&gt;ASCI
      
    
    </summary>
    
      <category term="Notes" scheme="https://iris-cyy.github.io/categories/Notes/"/>
    
      <category term="Python" scheme="https://iris-cyy.github.io/categories/Notes/Python/"/>
    
    
      <category term="Notes" scheme="https://iris-cyy.github.io/tags/Notes/"/>
    
      <category term="Python" scheme="https://iris-cyy.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【PAT-Advanced】1012 The Best Rank</title>
    <link href="https://iris-cyy.github.io//PAT/Advanced/2020-02-16/pat_1012/"/>
    <id>https://iris-cyy.github.io//PAT/Advanced/2020-02-16/pat_1012/</id>
    <published>2020-02-16T09:56:28.000Z</published>
    <updated>2020-02-25T15:50:47.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: <code>C</code> - C Programming Language, <code>M</code> - Mathematics (Calculus or Linear Algrbra), and <code>E</code> - English. At the mean time, we encourage students by emphasizing on their best ranks – that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student.</p><p>For example, The grades of <code>C</code>, <code>M</code>, <code>E</code> and <code>A</code> - Average of 4 students are given as the following:</p><blockquote><table><thead><tr><th>StudentID</th><th>C</th><th>M</th><th>E</th><th>A</th></tr></thead><tbody><tr><td>310101</td><td>98</td><td>85</td><td>88</td><td>90</td></tr><tr><td>310102</td><td>70</td><td>95</td><td>88</td><td>84</td></tr><tr><td>310103</td><td>82</td><td>87</td><td>94</td><td>88</td></tr><tr><td>310104</td><td>91</td><td>91</td><td>91</td><td>91</td></tr></tbody></table></blockquote><p>Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing 2 numbers $N$ and $M (≤2000)$, which are the total number of students, and the number of students who would check their ranks, respectively. Then $N$ lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of <code>C</code>, <code>M</code> and <code>E</code>. Then there are $M$ lines, each containing a student ID.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each of the $M$ students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space.</p><p>The priorities of the ranking methods are ordered as <code>A</code> &gt; <code>C</code> &gt; <code>M</code> &gt; <code>E</code>. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority.</p><p>If a student is not on the grading list, simply output <code>N/A</code>.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><blockquote><p>5 6<br>310101 98 85 88<br>310102 70 95 88<br>310103 82 87 94<br>310104 91 91 91<br>310105 85 90 90<br>310101<br>310102<br>310103<br>310104<br>310105<br>999999</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><blockquote><p>1 C<br>1 M<br>1 E<br>1 A<br>3 A<br>N/A</p></blockquote><p><br></p><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目不太难，比较考察对STL的应用</p><p>题目对算法复杂度要求不太高，所以直接用STL的sort函数排序，线性遍历</p><p>用到<code>vector</code>以及一些相关的函数</p><p>思路是，用<code>vector</code>存储学生的列表和分数的列表，将分数列表中的分数按从大到小排序之后，下标即对应排名（其中如果有相同分数，取最小的下标）</p><p>需要注意的是：</p><ul><li>相同分数的排序<br>如<code>95 90 90 88</code>排名是<code>1 2 2 4</code></li><li>优先级<code>A &gt; C &gt; M &gt; E</code></li><li>平均分取整（直接<code>int</code>就行）</li></ul><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0 1 2 3</span></span><br><span class="line"><span class="comment">//A C M E</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> grade[<span class="number">4</span>]; <span class="comment">//各科分数</span></span><br><span class="line">    <span class="keyword">int</span> rank[<span class="number">4</span>]; <span class="comment">//各科排名</span></span><br><span class="line">    <span class="keyword">int</span> bestRank; <span class="comment">//最高排名，0表示还没找</span></span><br><span class="line">    <span class="keyword">int</span> bestCourse; <span class="comment">//最高排名对应的学科</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;struct student&gt; students; <span class="comment">//学生列表</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Rank[<span class="number">4</span>]; <span class="comment">//分数列表，下标对应排名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> course[<span class="number">4</span>] = &#123;<span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'M'</span>, <span class="string">'E'</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> M, N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到该学生各科分数对应的排名</span></span><br><span class="line"><span class="function">struct student <span class="title">findRank</span><span class="params">(struct student stu)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ra, rc, rm, re;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;Rank[i].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Rank[i][j] == stu.grade[i])&#123;</span><br><span class="line">                stu.rank[i] = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//注意这个break不能漏</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找最高排名，标注对应课程</span></span><br><span class="line">    ra = stu.rank[<span class="number">0</span>];</span><br><span class="line">    rc = stu.rank[<span class="number">1</span>];</span><br><span class="line">    rm = stu.rank[<span class="number">2</span>];</span><br><span class="line">    re = stu.rank[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span>(ra &lt;= rc)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ra &lt;= rm)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ra &lt;= re)&#123;</span><br><span class="line">                stu.bestRank = ra;</span><br><span class="line">                stu.bestCourse = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stu.bestRank = re;</span><br><span class="line">                stu.bestCourse = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(rm &lt;= re)&#123;</span><br><span class="line">                stu.bestRank = rm;</span><br><span class="line">                stu.bestCourse = <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stu.bestRank = re;</span><br><span class="line">                stu.bestCourse = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rc &lt;= rm)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rc &lt;= re)&#123;</span><br><span class="line">                stu.bestRank = rc;</span><br><span class="line">                stu.bestCourse = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stu.bestRank = re;</span><br><span class="line">                stu.bestCourse = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(rm &lt;= re)&#123;</span><br><span class="line">                stu.bestRank = rm;</span><br><span class="line">                stu.bestCourse = <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stu.bestRank = re;</span><br><span class="line">                stu.bestCourse = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">int</span> id, c, m, e, a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">newStu</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; id &gt;&gt; c &gt;&gt; m &gt;&gt; e;</span><br><span class="line">        a = (c + m + e) / <span class="number">3</span>; <span class="comment">//平均分</span></span><br><span class="line">        newStu.id = id;</span><br><span class="line">        newStu.grade[<span class="number">0</span>] = a;</span><br><span class="line">        Rank[<span class="number">0</span>].push_back(a);</span><br><span class="line">        newStu.grade[<span class="number">1</span>] = c;</span><br><span class="line">        Rank[<span class="number">1</span>].push_back(c);</span><br><span class="line">        newStu.grade[<span class="number">2</span>] = m;</span><br><span class="line">        Rank[<span class="number">2</span>].push_back(m);</span><br><span class="line">        newStu.grade[<span class="number">3</span>] = e;</span><br><span class="line">        Rank[<span class="number">3</span>].push_back(e);</span><br><span class="line">        students.push_back(newStu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//各分数列表按从高到低排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">        sort(Rank[i].<span class="built_in">begin</span>(), Rank[i].<span class="built_in">end</span>(), cmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;M; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">find</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;N; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(students[j].id == id)&#123;</span><br><span class="line">                <span class="built_in">find</span> = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果已经找到过最佳排名就不用再调一遍函数，直接输出就好。否则调函数求一下</span></span><br><span class="line">                <span class="comment">//（减少重复检索时候的复杂度）</span></span><br><span class="line">                <span class="keyword">if</span>(students[j].bestRank == <span class="number">0</span>)&#123; </span><br><span class="line">                    students[j] = findRank(students[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; students[j].bestRank &lt;&lt; <span class="string">" "</span> &lt;&lt; course[students[j].bestCourse] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"N/A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;p&gt;To evaluate the performance of our first year CS m
      
    
    </summary>
    
      <category term="PAT" scheme="https://iris-cyy.github.io/categories/PAT/"/>
    
      <category term="Advanced" scheme="https://iris-cyy.github.io/categories/PAT/Advanced/"/>
    
    
      <category term="PAT" scheme="https://iris-cyy.github.io/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>【PAT-Advanced】1011 World Cup Betting</title>
    <link href="https://iris-cyy.github.io//PAT/Advanced/2020-02-11/pat_1011/"/>
    <id>https://iris-cyy.github.io//PAT/Advanced/2020-02-11/pat_1011/</id>
    <published>2020-02-11T09:53:20.000Z</published>
    <updated>2020-02-11T09:57:06.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.</p><p>Chinese Football Lottery provided a “Triple Winning” game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results – namely <code>W</code> for win, <code>T</code> for tie, and <code>L</code> for lose. There was an odd assigned to each result. The winner’s odd would be the product of the three odds times 65%.</p><p>For example, 3 games’ odds are given as the following:</p><blockquote><p> W    T    L<br>1.1  2.5  1.7<br>1.2  3.1  1.6<br>4.1  1.2  1.1</p></blockquote><p>To obtain the maximum profit, one must buy <code>W</code> for the 3rd game, <code>T</code> for the 2nd game, and <code>T</code> for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1×3.1×2.5×65%−1)×2=39.31 yuans (accurate up to 2 decimal places).</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to <code>W</code>, <code>T</code> and <code>L</code>.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><blockquote><p>1.1 2.5 1.7<br>1.2 3.1 1.6<br>4.1 1.2 1.1</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><blockquote><p>T T W 39.31</p></blockquote><p><br></p><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>简单题直接上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">maxp</span><span class="params">(<span class="keyword">double</span> w, <span class="keyword">double</span> t, <span class="keyword">double</span> l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w &gt; t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; w)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"L "</span>;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"W "</span>;</span><br><span class="line">            <span class="keyword">return</span> w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; t)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"L "</span>;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"T "</span>;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> profit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> w[<span class="number">3</span>], t[<span class="number">3</span>], l[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; t[i] &gt;&gt; l[i];</span><br><span class="line">        profit *= maxp(w[i], t[i], l[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    profit = (profit * <span class="number">0.65</span> - <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, profit);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;p&gt;With the 2010 FIFA World Cup running, football fan
      
    
    </summary>
    
      <category term="PAT" scheme="https://iris-cyy.github.io/categories/PAT/"/>
    
      <category term="Advanced" scheme="https://iris-cyy.github.io/categories/PAT/Advanced/"/>
    
    
      <category term="PAT" scheme="https://iris-cyy.github.io/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>【DBS】Lecture 06. Relational Database Design</title>
    <link href="https://iris-cyy.github.io//Notes/Database-System/2020-02-11/dbs06/"/>
    <id>https://iris-cyy.github.io//Notes/Database-System/2020-02-11/dbs06/</id>
    <published>2020-02-11T09:17:19.000Z</published>
    <updated>2020-02-11T09:19:53.114Z</updated>
    
    <content type="html"><![CDATA[<p><img src="dbs06.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcmlzc3N5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-20200211171822167.png" width=80%></p><h2 id="First-Normal-Form"><a href="#First-Normal-Form" class="headerlink" title="First Normal Form"></a>First Normal Form</h2><p>atomic</p><h2 id="Functional-dependencies"><a href="#Functional-dependencies" class="headerlink" title="Functional dependencies"></a>Functional dependencies</h2><p>The functional dependency α → β holds on R if and only if for any legal relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes α, they also agree on the attributes β, i.e., t1[α] = t2[α] ⟹ t1[α] = t2[β] </p><p>Trivial: α → β, if β ⊆ α         (平凡的函数依赖) </p><p>Non-trivial: α → β , if β ⊈ α    (非平凡的函数依赖) </p><h2 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h2><p>The set of all functional dependencies logically implied by F is the closure of F, denoted by F+ (函数依赖集F的闭包)</p><p>E.g., F = {A → B, B → C}, F+ = {A → B, B → C, A → C, A α A, AB → A, AB → B, AC → C, A → BC, …} </p><p>Armstrong’s Axioms provide inference rules to find F+. </p><p>We can find all of F+ by applying Armstrong’s Axioms: </p><p>If β ⊆ α, then α → β               (reflexivity, 自反律) — trivial </p><p>If α → β, then ?α → ?β (?α → β)    (augmentation, 增补律) </p><p>If α → β, and β → ?, then α → ?   (transitivity, 传递律) </p><p>If α → β and α → ? holds, then α → β? holds (union, 合并律) </p><p>If α → β? holds, then α → β and α → ? holds (decomposition, 分解律) </p><p>If α → β and β? → δ holds, then α? → δ holds (pseudotransitivity, 伪传递律) </p><h2 id="Canonical-cover（正则覆盖）"><a href="#Canonical-cover（正则覆盖）" class="headerlink" title="Canonical cover（正则覆盖）"></a>Canonical cover（正则覆盖）</h2><p>minimal set of functional dependencies in F</p><h2 id="Dependency-preservation（依赖保持）"><a href="#Dependency-preservation（依赖保持）" class="headerlink" title="Dependency preservation（依赖保持）"></a>Dependency preservation（依赖保持）</h2><h2 id="lossless-join-无损分解"><a href="#lossless-join-无损分解" class="headerlink" title="lossless-join 无损分解"></a>lossless-join 无损分解</h2><p>$R_1 \bigcap R_2 \rightarrow R_1 or R_1 \bigcap R_2 \rightarrow R_2$</p><h2 id="Boyce-Codd-Normal-Form"><a href="#Boyce-Codd-Normal-Form" class="headerlink" title="Boyce-Codd Normal Form"></a>Boyce-Codd Normal Form</h2><p><img src="/images/dbs/dbs06.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcmlzc3N5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-20200211171730017.png" alt="在这里插入图片描述"></p><h2 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h2><p><img src="/images/dbs/dbs06.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcmlzc3N5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-20200211171730061.png" alt="在这里插入图片描述"></p><p>If a relation is in BCNF, it is in 3NF.</p><p><br></p><hr><p>另外一些相关的博文：</p><p><a href="https://www.cnblogs.com/langdashu/p/5924082.html" target="_blank" rel="noopener">https://www.cnblogs.com/langdashu/p/5924082.html</a></p><p>BCNF 无损分解：<a href="https://blog.csdn.net/panxiqie___/article/details/38899021" target="_blank" rel="noopener">https://blog.csdn.net/panxiqie___/article/details/38899021</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;dbs06.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcmlzc3N5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_
      
    
    </summary>
    
      <category term="Notes" scheme="https://iris-cyy.github.io/categories/Notes/"/>
    
      <category term="Database System" scheme="https://iris-cyy.github.io/categories/Notes/Database-System/"/>
    
    
      <category term="Notes" scheme="https://iris-cyy.github.io/tags/Notes/"/>
    
      <category term="DBS" scheme="https://iris-cyy.github.io/tags/DBS/"/>
    
  </entry>
  
  <entry>
    <title>【DBS】Lecture 09. Storage and File Structure</title>
    <link href="https://iris-cyy.github.io//Notes/Database-System/2020-02-11/dbs09/"/>
    <id>https://iris-cyy.github.io//Notes/Database-System/2020-02-11/dbs09/</id>
    <published>2020-02-11T09:13:49.000Z</published>
    <updated>2020-02-11T09:16:59.974Z</updated>
    
    <content type="html"><![CDATA[<p>存储器层次结构（向上变快变贵但是易失）</p><p><img src="/images/dbs/dbs09.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lyaXNfY3l5,size_16,color_FFFFFF,t_70-20200211171459877.png" alt="img"></p><p><strong>基本存储</strong>(primary storage): 高速缓冲存储器(cache)、主存储器(main memory)</p><p><strong>辅助存储</strong>(secondary storage)或<strong>联机存储</strong>(online storage): 基本存储下一层，如磁盘(magnetic disk)</p><p><strong>三级存储</strong>(tertiary storage)或<strong>脱机存储</strong>(offline storage): 最底层，如磁带(magnetic tapes)或光盘(optical disk)</p><p>主存储器以上均为<strong>易失性存储</strong>(volatile storage)：设备断电后失去所有内容</p><p>独立磁盘冗余阵列(RAID)</p><p>平均故障时间(MTTF)</p><p>RAID level:</p><p><img src="/images/dbs/dbs09.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lyaXNfY3l5,size_16,color_FFFFFF,t_70-20200211171600064.png" width=50%></p><h3 id="Choice-of-RAID-Level"><a href="#Choice-of-RAID-Level" class="headerlink" title="Choice of RAID Level"></a>Choice of RAID Level</h3><p>Factors in choosing RAID level </p><ul><li>Monetary cost </li><li>Performance: Number of I/O operations per second, and bandwidth during normal operation </li><li>Performance during failure </li><li>Performance during rebuild of failed disk <ul><li>Including time taken to rebuild failed disk </li></ul></li></ul><p>RAID 0 is used only when data safety is not important </p><ul><li>E.g., data can be recovered quickly from other sources</li></ul><p>Level 2 and 4 never used since they are subsumed by 3 and 5<br>Level 3 is not used anymore since bit-striping forces single block  reads to access all disks, wasting disk arm movement, which block striping (level 5) avoids<br>Level 6 is rarely used since levels 1 and 5 offer adequate safety for almost all applications<br><u>So competition is between 1 and 5 only</u></p><p>Level 1 provides much better write performance than level 5</p><ul><li>Level 5 requires at least 2 block reads and 2 block writes to write a single block, whereas Level 1 only requires 2 block writes</li><li>Level 1 preferred for high update environments such as log disks</li></ul><p>Level 1 had higher storage cost than level 5</p><ul><li>Disk drive capacities increasing rapidly (50%/year) whereas disk access times have decreased much less (x 3 in 10 years) </li><li>I/O requirements have increased greatly, e.g. for Web servers</li><li>When enough disks have been bought to satisfy required rate of I/O, they often have spare storage capacity<ul><li>So there is often no extra monetary cost for Level 1! </li></ul></li></ul><p>Level 5 is preferred for applications with low update rate, and large amounts of data.<br>Level 1 is preferred for all other applications. </p><h3 id="Buffer-Manager"><a href="#Buffer-Manager" class="headerlink" title="Buffer Manager"></a>Buffer Manager</h3><p>当Buffer的空闲区不够，不能容下新读入的Block时，需要将Buffer中 原有Block覆盖(替换)。主要策略为:</p><ul><li>LRU strategy (Least Recently Used, 最近最少使用策略): Replace the block which was least recently used.</li><li>MRU strategy (Most recently used, 最近最常用策略): System must pin the block currently being processed. After the final tuple of that block has been processed, the block is unpinned, and it becomes the most recently used block.（最优）</li><li>Toss-immediate，立即丢弃策略：处理完的元组立即丢弃</li></ul><h3 id="File-Organization"><a href="#File-Organization" class="headerlink" title="File Organization"></a>File Organization</h3><ul><li>定长记录</li><li>变长记录</li></ul><h3 id="Organization-of-Records-in-Files"><a href="#Organization-of-Records-in-Files" class="headerlink" title="Organization of Records in Files"></a>Organization of Records in Files</h3><ul><li>heap file 堆文件，流水文件：<br> a record can be placed anywhere in the file where there is space</li><li>sequential file 顺序文件：<br>store records in sequential order, based on the value of a search key of each record</li><li>hashing file 散列文件：<br>a hash function computed on some attribute of each record; the result specifies in which block of the file the record should be placed</li><li>clustering file organization 聚集文件组织：<br>records of several different relations can be stored in the same file<br>Motivation: store related records in different relations on the same block to minimize I/O</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;存储器层次结构（向上变快变贵但是易失）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dbs/dbs09.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ub
      
    
    </summary>
    
      <category term="Notes" scheme="https://iris-cyy.github.io/categories/Notes/"/>
    
      <category term="Database System" scheme="https://iris-cyy.github.io/categories/Notes/Database-System/"/>
    
    
      <category term="Notes" scheme="https://iris-cyy.github.io/tags/Notes/"/>
    
      <category term="DBS" scheme="https://iris-cyy.github.io/tags/DBS/"/>
    
  </entry>
  
</feed>
